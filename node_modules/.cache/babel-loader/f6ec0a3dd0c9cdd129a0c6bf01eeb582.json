{"ast":null,"code":"import debounce from 'lodash-es/debounce';\nimport isEqual$1 from 'lodash-es/isEqual';\nimport qs__default, { stringify } from 'qs';\nimport { createElement, createContext, Component, Fragment, useEffect, useRef, useCallback, useContext, useState } from 'react';\nimport noop from 'lodash-es/noop';\nimport url from 'url';\nimport merge from 'lodash-es/merge';\nimport equal from 'react-fast-compare';\nimport isEqualWith from 'lodash-es/isEqualWith';\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  subClass.__proto__ = superClass;\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n} // A type of promise-like that resolves synchronously and supports only one observer\n\n\nconst _iteratorSymbol = /*#__PURE__*/typeof Symbol !== \"undefined\" ? Symbol.iterator || (Symbol.iterator = Symbol(\"Symbol.iterator\")) : \"@@iterator\";\n\nconst _asyncIteratorSymbol = /*#__PURE__*/typeof Symbol !== \"undefined\" ? Symbol.asyncIterator || (Symbol.asyncIterator = Symbol(\"Symbol.asyncIterator\")) : \"@@asyncIterator\"; // Asynchronously call a function and send errors to recovery continuation\n\n\nfunction _catch(body, recover) {\n  try {\n    var result = body();\n  } catch (e) {\n    return recover(e);\n  }\n\n  if (result && result.then) {\n    return result.then(void 0, recover);\n  }\n\n  return result;\n}\n\nvar Context = /*#__PURE__*/createContext({\n  base: \"\",\n  parentPath: \"\",\n  resolve: function resolve(data) {\n    return data;\n  },\n  requestOptions: {},\n  onError: noop,\n  queryParams: {}\n});\n\nvar RestfulReactProvider = /*#__PURE__*/function (_React$Component) {\n  _inheritsLoose(RestfulReactProvider, _React$Component);\n\n  function RestfulReactProvider() {\n    return _React$Component.apply(this, arguments) || this;\n  }\n\n  var _proto = RestfulReactProvider.prototype;\n\n  _proto.render = function render() {\n    var _this$props = this.props,\n        children = _this$props.children,\n        value = _objectWithoutPropertiesLoose(_this$props, [\"children\"]);\n\n    return createElement(Context.Provider, {\n      value: _extends({\n        onError: noop,\n        resolve: function resolve(data) {\n          return data;\n        },\n        requestOptions: {},\n        parentPath: \"\",\n        queryParams: value.queryParams || {}\n      }, value)\n    }, children);\n  };\n\n  return RestfulReactProvider;\n}(Component);\n\nRestfulReactProvider.displayName = \"RestfulProviderContext\";\nvar RestfulReactConsumer = Context.Consumer;\n\nvar composeUrl = function composeUrl(base, parentPath, path) {\n  if (base === void 0) {\n    base = \"\";\n  }\n\n  if (parentPath === void 0) {\n    parentPath = \"\";\n  }\n\n  if (path === void 0) {\n    path = \"\";\n  }\n\n  var composedPath = composePath(parentPath, path);\n  /* If the base is empty, preceding slash will be trimmed during composition */\n\n  if (base === \"\" && composedPath.startsWith(\"/\")) {\n    return composedPath;\n  }\n  /* If the base contains a trailing slash, it will be trimmed during composition */\n\n\n  return base.endsWith(\"/\") ? \"\" + base.slice(0, -1) + composedPath : \"\" + base + composedPath;\n};\n/**\r\n * If the path starts with slash, it is considered as absolute url.\r\n * If not, it is considered as relative url.\r\n * For example,\r\n * parentPath = \"/someBasePath\" and path = \"/absolute\" resolves to \"/absolute\"\r\n * whereas,\r\n * parentPath = \"/someBasePath\" and path = \"relative\" resolves to \"/someBasePath/relative\"\r\n */\n\n\nvar composePath = function composePath(parentPath, path) {\n  if (parentPath === void 0) {\n    parentPath = \"\";\n  }\n\n  if (path === void 0) {\n    path = \"\";\n  }\n\n  if (path.startsWith(\"/\") && path.length > 1) {\n    return url.resolve(parentPath, path);\n  } else if (path !== \"\" && path !== \"/\") {\n    return parentPath + \"/\" + path;\n  } else {\n    return parentPath;\n  }\n};\n\nvar processResponse = function processResponse(response) {\n  try {\n    if (response.status === 204) {\n      return Promise.resolve({\n        data: undefined,\n        responseError: false\n      });\n    }\n\n    if ((response.headers.get(\"content-type\") || \"\").includes(\"application/json\")) {\n      return Promise.resolve(_catch(function () {\n        return Promise.resolve(response.json()).then(function (_response$json) {\n          return {\n            data: _response$json,\n            responseError: false\n          };\n        });\n      }, function (e) {\n        return {\n          data: e.message,\n          responseError: true\n        };\n      }));\n    } else {\n      return Promise.resolve(response.text()).then(function (_response$text) {\n        return {\n          data: _response$text,\n          responseError: false\n        };\n      });\n    }\n  } catch (e) {\n    return Promise.reject(e);\n  }\n};\n\nvar resolveData = function resolveData(_ref) {\n  var data = _ref.data,\n      resolve = _ref.resolve;\n\n  try {\n    var _temp5 = function _temp5() {\n      return {\n        data: resolvedData,\n        error: resolveError\n      };\n    };\n\n    var resolvedData = null;\n    var resolveError = null;\n\n    var _temp6 = _catch(function () {\n      var _temp2 = function () {\n        if (resolve) {\n          var _temp7 = function _temp7(_resolvedDataOrPromis) {\n            resolvedData = _resolvedDataOrPromis;\n          };\n\n          var resolvedDataOrPromise = resolve(data);\n          var _resolvedDataOrPromis3 = resolvedDataOrPromise.then;\n          return _resolvedDataOrPromis3 ? Promise.resolve(resolvedDataOrPromise).then(_temp7) : _temp7(resolvedDataOrPromise);\n        } else {\n          resolvedData = data;\n        }\n      }();\n\n      if (_temp2 && _temp2.then) return _temp2.then(function () {});\n    }, function (err) {\n      resolvedData = null;\n      resolveError = {\n        message: \"RESOLVE_ERROR\",\n        data: JSON.stringify(err)\n      };\n    });\n\n    return Promise.resolve(_temp6 && _temp6.then ? _temp6.then(_temp5) : _temp5(_temp6));\n  } catch (e) {\n    return Promise.reject(e);\n  }\n};\n/**\r\n * The <Get /> component without Context. This\r\n * is a named class because it is useful in\r\n * debugging.\r\n */\n\n\nvar ContextlessGet = /*#__PURE__*/function (_React$Component) {\n  _inheritsLoose(ContextlessGet, _React$Component);\n\n  function ContextlessGet(props) {\n    var _this;\n\n    _this = _React$Component.call(this, props) || this;\n    /**\r\n     * Abort controller to cancel the current fetch query\r\n     */\n\n    _this.abortController = new AbortController();\n    _this.signal = _this.abortController.signal;\n    _this.state = {\n      data: null,\n      response: null,\n      loading: !_this.props.lazy,\n      error: null\n    };\n\n    _this.getRequestOptions = function (extraOptions, extraHeaders) {\n      try {\n        var _temp3 = function _temp3(_result) {\n          return _exit2 ? _result : _extends({}, extraOptions, {}, requestOptions, {\n            headers: new Headers(_extends({}, typeof extraHeaders !== \"boolean\" ? extraHeaders : {}, {}, (extraOptions || {}).headers, {}, (requestOptions || {}).headers))\n          });\n        };\n\n        var _exit2 = false;\n        var requestOptions = _this.props.requestOptions;\n\n        var _temp4 = function () {\n          if (typeof requestOptions === \"function\") {\n            return Promise.resolve(requestOptions()).then(function (options) {\n              _exit2 = true;\n              return _extends({}, extraOptions, {}, options, {\n                headers: new Headers(_extends({}, typeof extraHeaders !== \"boolean\" ? extraHeaders : {}, {}, (extraOptions || {}).headers, {}, options.headers))\n              });\n            });\n          }\n        }();\n\n        return Promise.resolve(_temp4 && _temp4.then ? _temp4.then(_temp3) : _temp3(_temp4));\n      } catch (e) {\n        return Promise.reject(e);\n      }\n    };\n\n    _this.fetch = function (requestPath, thisRequestOptions) {\n      try {\n        var _this$props = _this.props,\n            base = _this$props.base,\n            __internal_hasExplicitBase = _this$props.__internal_hasExplicitBase,\n            parentPath = _this$props.parentPath,\n            path = _this$props.path,\n            resolve = _this$props.resolve;\n\n        if (_this.state.error || !_this.state.loading) {\n          _this.setState(function () {\n            return {\n              error: null,\n              loading: true\n            };\n          });\n        }\n\n        var makeRequestPath = function makeRequestPath() {\n          var url;\n\n          if (__internal_hasExplicitBase) {\n            url = composeUrl(base, \"\", path || \"\");\n          } else {\n            url = composeUrl(base, parentPath, requestPath || path || \"\");\n          } // We use ! because it's in defaultProps\n\n\n          if (Object.keys(_this.props.queryParams).length) {\n            url += \"?\" + stringify(_this.props.queryParams);\n          }\n\n          return url;\n        };\n\n        return Promise.resolve(_this.getRequestOptions(thisRequestOptions)).then(function (_this$getRequestOptio) {\n          var request = new Request(makeRequestPath(), _this$getRequestOptio);\n          return _catch(function () {\n            return Promise.resolve(fetch(request, {\n              signal: _this.signal\n            })).then(function (response) {\n              return Promise.resolve(processResponse(response)).then(function (_ref) {\n                var data = _ref.data,\n                    responseError = _ref.responseError; // avoid state updates when component has been unmounted\n\n                if (_this.signal.aborted) {\n                  return;\n                }\n\n                if (!response.ok || responseError) {\n                  var error = {\n                    message: \"Failed to fetch: \" + response.status + \" \" + response.statusText + (responseError ? \" - \" + data : \"\"),\n                    data: data,\n                    status: response.status\n                  };\n\n                  _this.setState({\n                    loading: false,\n                    error: error\n                  });\n\n                  if (!_this.props.localErrorOnly && _this.props.onError) {\n                    _this.props.onError(error, function () {\n                      return _this.fetch(requestPath, thisRequestOptions);\n                    }, response);\n                  }\n\n                  return null;\n                }\n\n                return Promise.resolve(resolveData({\n                  data: data,\n                  resolve: resolve\n                })).then(function (resolved) {\n                  _this.setState({\n                    loading: false,\n                    data: resolved.data,\n                    error: resolved.error\n                  });\n\n                  return data;\n                });\n              });\n            });\n          }, function (e) {\n            // avoid state updates when component has been unmounted\n            // and when fetch/processResponse threw an error\n            if (_this.signal.aborted) {\n              return;\n            }\n\n            _this.setState({\n              loading: false,\n              error: {\n                message: \"Failed to fetch: \" + e.message,\n                data: e\n              }\n            });\n          });\n        });\n      } catch (e) {\n        return Promise.reject(e);\n      }\n    };\n\n    if (typeof props.debounce === \"object\") {\n      _this.fetch = debounce(_this.fetch, props.debounce.wait, props.debounce.options);\n    } else if (typeof props.debounce === \"number\") {\n      _this.fetch = debounce(_this.fetch, props.debounce);\n    } else if (props.debounce) {\n      _this.fetch = debounce(_this.fetch);\n    }\n\n    return _this;\n  }\n\n  var _proto = ContextlessGet.prototype;\n\n  _proto.componentDidMount = function componentDidMount() {\n    if (!this.props.lazy) {\n      this.fetch();\n    }\n  };\n\n  _proto.componentDidUpdate = function componentDidUpdate(prevProps) {\n    var base = prevProps.base,\n        parentPath = prevProps.parentPath,\n        path = prevProps.path,\n        resolve = prevProps.resolve,\n        queryParams = prevProps.queryParams;\n\n    if (base !== this.props.base || parentPath !== this.props.parentPath || path !== this.props.path || !isEqual$1(queryParams, this.props.queryParams) || // both `resolve` props need to _exist_ first, and then be equivalent.\n    resolve && this.props.resolve && resolve.toString() !== this.props.resolve.toString()) {\n      if (!this.props.lazy) {\n        this.fetch();\n      }\n    }\n  };\n\n  _proto.componentWillUnmount = function componentWillUnmount() {\n    this.abortController.abort();\n  };\n\n  _proto.render = function render() {\n    var _this$props2 = this.props,\n        children = _this$props2.children,\n        wait = _this$props2.wait,\n        path = _this$props2.path,\n        base = _this$props2.base,\n        parentPath = _this$props2.parentPath;\n    var _this$state = this.state,\n        data = _this$state.data,\n        error = _this$state.error,\n        loading = _this$state.loading,\n        response = _this$state.response;\n\n    if (wait && data === null && !error) {\n      return createElement(Fragment, null); // Show nothing until we have data.\n    }\n\n    return children(data, {\n      loading: loading,\n      error: error\n    }, {\n      refetch: this.fetch\n    }, {\n      response: response,\n      absolutePath: composeUrl(base, parentPath, path)\n    });\n  };\n\n  return ContextlessGet;\n}(Component);\n\nContextlessGet.defaultProps = {\n  base: \"\",\n  parentPath: \"\",\n  resolve: function resolve(unresolvedData) {\n    return unresolvedData;\n  },\n  queryParams: {}\n};\n/**\r\n * The <Get /> component _with_ context.\r\n * Context is used to compose path props,\r\n * and to maintain the base property against\r\n * which all requests will be made.\r\n *\r\n * We compose Consumers immediately with providers\r\n * in order to provide new `parentPath` props that contain\r\n * a segment of the path, creating composable URLs.\r\n */\n\nfunction Get(props) {\n  return createElement(RestfulReactConsumer, null, function (contextProps) {\n    return createElement(RestfulReactProvider, Object.assign({}, contextProps, {\n      parentPath: composePath(contextProps.parentPath, props.path)\n    }), createElement(ContextlessGet, Object.assign({}, contextProps, props, {\n      queryParams: _extends({}, contextProps.queryParams, {}, props.queryParams),\n      __internal_hasExplicitBase: Boolean(props.base)\n    })));\n  });\n}\n/**\r\n * The <Poll /> component without context.\r\n */\n\n\nvar ContextlessPoll = /*#__PURE__*/function (_React$Component) {\n  _inheritsLoose(ContextlessPoll, _React$Component);\n\n  function ContextlessPoll() {\n    var _this;\n\n    _this = _React$Component.apply(this, arguments) || this;\n    _this.state = {\n      data: null,\n      previousData: null,\n      loading: !_this.props.lazy,\n      lastResponse: null,\n      polling: !_this.props.lazy,\n      finished: false,\n      error: null\n    };\n    _this.keepPolling = !_this.props.lazy;\n    /**\r\n     * Abort controller to cancel the current fetch query\r\n     */\n\n    _this.abortController = new AbortController();\n    _this.signal = _this.abortController.signal;\n\n    _this.isModified = function (response, nextData) {\n      if (response.status === 304) {\n        return false;\n      }\n\n      if (equal(_this.state.data, nextData)) {\n        return false;\n      }\n\n      return true;\n    };\n\n    _this.getRequestOptions = function () {\n      return typeof _this.props.requestOptions === \"function\" ? _this.props.requestOptions() : _this.props.requestOptions || {};\n    }; // 304 is not a OK status code but is green in Chrome 🤦🏾‍♂️\n\n\n    _this.isResponseOk = function (response) {\n      return response.ok || response.status === 304;\n    };\n    /**\r\n     * This thing does the actual poll.\r\n     */\n\n\n    _this.cycle = function () {\n      try {\n        var _temp3 = function _temp3(_result) {\n          if (_exit2) return _result; // If we should keep going,\n\n          var _this$props = _this.props,\n              base = _this$props.base,\n              path = _this$props.path,\n              interval = _this$props.interval,\n              wait = _this$props.wait;\n          var lastPollIndex = _this.state.lastPollIndex;\n          return Promise.resolve(_this.getRequestOptions()).then(function (requestOptions) {\n            var url = composeUrl(base, \"\", path); // We use a ! because it's in defaultProps\n\n            if (Object.keys(_this.props.queryParams).length) {\n              url += \"?\" + stringify(_this.props.queryParams);\n            }\n\n            var request = new Request(url, _extends({}, requestOptions, {\n              headers: _extends({\n                Prefer: \"wait=\" + wait + \"s;\" + (lastPollIndex ? \"index=\" + lastPollIndex : \"\")\n              }, requestOptions.headers)\n            }));\n            return _catch(function () {\n              return Promise.resolve(fetch(request, {\n                signal: _this.signal\n              })).then(function (response) {\n                return Promise.resolve(processResponse(response)).then(function (_ref) {\n                  var data = _ref.data,\n                      responseError = _ref.responseError;\n\n                  if (!_this.keepPolling || _this.signal.aborted) {\n                    // Early return if we have stopped polling or component was unmounted\n                    // to avoid memory leaks\n                    return;\n                  }\n\n                  if (!_this.isResponseOk(response) || responseError) {\n                    var error = {\n                      message: \"Failed to poll: \" + response.status + \" \" + response.statusText + (responseError ? \" - \" + data : \"\"),\n                      data: data,\n                      status: response.status\n                    };\n\n                    _this.setState({\n                      loading: false,\n                      lastResponse: response,\n                      error: error\n                    });\n\n                    if (!_this.props.localErrorOnly && _this.props.onError) {\n                      _this.props.onError(error, function () {\n                        return Promise.resolve();\n                      }, response);\n                    }\n                  } else if (_this.isModified(response, data)) {\n                    _this.setState(function (prevState) {\n                      return {\n                        loading: false,\n                        lastResponse: response,\n                        previousData: prevState.data,\n                        data: data,\n                        error: null,\n                        lastPollIndex: response.headers.get(\"x-polling-index\") || undefined\n                      };\n                    });\n                  } // Wait for interval to pass.\n\n\n                  return Promise.resolve(new Promise(function (resolvePromise) {\n                    return setTimeout(resolvePromise, interval);\n                  })).then(function () {\n                    _this.cycle(); // Do it all again!\n\n                  });\n                });\n              });\n            }, function () {});\n          });\n        };\n\n        var _exit2 = false; // Have we stopped?\n\n        if (!_this.keepPolling) {\n          return Promise.resolve(); // stop.\n        } // Should we stop?\n\n\n        var _temp4 = function () {\n          if (_this.props.until && _this.props.until(_this.state.data, _this.state.lastResponse)) {\n            return Promise.resolve(_this.stop()).then(function () {\n              // stop.\n              _exit2 = true;\n            });\n          }\n        }();\n\n        return Promise.resolve(_temp4 && _temp4.then ? _temp4.then(_temp3) : _temp3(_temp4));\n      } catch (e) {\n        return Promise.reject(e);\n      }\n    };\n\n    _this.start = function () {\n      _this.keepPolling = true;\n\n      if (!_this.state.polling) {\n        _this.setState(function () {\n          return {\n            polling: true\n          };\n        }); // let everyone know we're done here.\n\n      }\n\n      _this.cycle();\n    };\n\n    _this.stop = function () {\n      _this.keepPolling = false;\n\n      _this.setState(function () {\n        return {\n          polling: false,\n          finished: true\n        };\n      }); // let everyone know we're done here.\n\n    };\n\n    return _this;\n  }\n\n  var _proto = ContextlessPoll.prototype;\n\n  _proto.componentDidMount = function componentDidMount() {\n    var _this$props2 = this.props,\n        path = _this$props2.path,\n        lazy = _this$props2.lazy;\n\n    if (path === undefined) {\n      throw new Error(\"[restful-react]: You're trying to poll something without a path. Please specify a \\\"path\\\" prop on your Poll component.\");\n    }\n\n    if (!lazy) {\n      this.start();\n    }\n  };\n\n  _proto.componentWillUnmount = function componentWillUnmount() {\n    // Cancel the current query\n    this.abortController.abort(); // Stop the polling cycle\n\n    this.stop();\n  };\n\n  _proto.render = function render() {\n    var _this$state = this.state,\n        response = _this$state.lastResponse,\n        previousData = _this$state.previousData,\n        data = _this$state.data,\n        polling = _this$state.polling,\n        loading = _this$state.loading,\n        error = _this$state.error,\n        finished = _this$state.finished;\n    var _this$props3 = this.props,\n        children = _this$props3.children,\n        base = _this$props3.base,\n        path = _this$props3.path,\n        resolve = _this$props3.resolve;\n    var meta = {\n      response: response,\n      absolutePath: composeUrl(base, \"\", path)\n    };\n    var states = {\n      polling: polling,\n      loading: loading,\n      error: error,\n      finished: finished\n    };\n    var actions = {\n      stop: this.stop,\n      start: this.start\n    }; // data is parsed only when poll has already resolved so response is defined\n\n    var resolvedData = response && resolve ? resolve(data, previousData) : data;\n    return children(resolvedData, states, actions, meta);\n  };\n\n  return ContextlessPoll;\n}(Component);\n\nContextlessPoll.defaultProps = {\n  interval: 1000,\n  wait: 60,\n  base: \"\",\n  resolve: function resolve(data) {\n    return data;\n  },\n  queryParams: {}\n};\n\nfunction Poll(props) {\n  // Compose Contexts to allow for URL nesting\n  return createElement(RestfulReactConsumer, null, function (contextProps) {\n    var contextRequestOptions = typeof contextProps.requestOptions === \"function\" ? contextProps.requestOptions() : contextProps.requestOptions || {};\n    var propsRequestOptions = typeof props.requestOptions === \"function\" ? props.requestOptions() : props.requestOptions || {};\n    return createElement(ContextlessPoll, Object.assign({}, contextProps, props, {\n      queryParams: _extends({}, contextProps.queryParams, {}, props.queryParams),\n      requestOptions: function () {\n        try {\n          return Promise.resolve(contextRequestOptions).then(function (_contextRequestOption) {\n            return Promise.resolve(propsRequestOptions).then(function (_propsRequestOptions) {\n              return merge(_contextRequestOption, _propsRequestOptions);\n            });\n          });\n        } catch (e) {\n          return Promise.reject(e);\n        }\n      }\n    }));\n  });\n}\n/**\r\n * The <Mutate /> component without Context. This\r\n * is a named class because it is useful in\r\n * debugging.\r\n */\n\n\nvar ContextlessMutate = /*#__PURE__*/function (_React$Component) {\n  _inheritsLoose(ContextlessMutate, _React$Component);\n\n  function ContextlessMutate() {\n    var _this;\n\n    _this = _React$Component.apply(this, arguments) || this;\n    _this.state = {\n      loading: false,\n      error: null\n    };\n    /**\r\n     * Abort controller to cancel the current fetch query\r\n     */\n\n    _this.abortController = new AbortController();\n    _this.signal = _this.abortController.signal;\n\n    _this.mutate = function (body, mutateRequestOptions) {\n      try {\n        var _temp5 = function _temp5(_providerRequestOptio) {\n          var _exit = false;\n\n          function _temp3(_result) {\n            return _exit ? _result : Promise.resolve(processResponse(response)).then(function (_ref) {\n              var data = _ref.data,\n                  responseError = _ref.responseError; // avoid state updates when component has been unmounted\n\n              if (_this.signal.aborted) {\n                return;\n              }\n\n              if (!response.ok || responseError) {\n                var error = {\n                  data: data,\n                  message: \"Failed to fetch: \" + response.status + \" \" + response.statusText,\n                  status: response.status\n                };\n\n                _this.setState({\n                  error: error,\n                  loading: false\n                });\n\n                if (!_this.props.localErrorOnly && _this.props.onError) {\n                  _this.props.onError(error, function () {\n                    return _this.mutate(body, mutateRequestOptions);\n                  }, response);\n                }\n\n                throw error;\n              }\n\n              _this.setState({\n                loading: false\n              });\n\n              if (_this.props.onMutate) {\n                _this.props.onMutate(body, data);\n              }\n\n              return data;\n            });\n          }\n\n          var request = new Request(makeRequestPath(), _extends({\n            method: verb,\n            body: _temp6\n          }, typeof providerRequestOptions === \"function\" ? providerRequestOptions() : providerRequestOptions, {}, mutateRequestOptions, {\n            headers: _extends({\n              \"content-type\": typeof body === \"object\" ? \"application/json\" : \"text/plain\"\n            }, typeof providerRequestOptions === \"function\" ? _providerRequestOptio.headers : _providerRequestOptio, {}, mutateRequestOptions ? mutateRequestOptions.headers : {})\n          })); // Type assertion for version of TypeScript that can't yet discriminate.\n\n          var response;\n\n          var _temp2 = _catch(function () {\n            return Promise.resolve(fetch(request, {\n              signal: _this.signal\n            })).then(function (_fetch) {\n              response = _fetch;\n            });\n          }, function (e) {\n            var error = {\n              message: \"Failed to fetch: \" + e.message,\n              data: \"\"\n            };\n\n            _this.setState({\n              error: error,\n              loading: false\n            });\n\n            if (!_this.props.localErrorOnly && _this.props.onError) {\n              _this.props.onError(error, function () {\n                return _this.mutate(body, mutateRequestOptions);\n              });\n            }\n\n            throw error;\n          });\n\n          return _temp2 && _temp2.then ? _temp2.then(_temp3) : _temp3(_temp2);\n        };\n\n        var _this$props = _this.props,\n            __internal_hasExplicitBase = _this$props.__internal_hasExplicitBase,\n            base = _this$props.base,\n            parentPath = _this$props.parentPath,\n            path = _this$props.path,\n            verb = _this$props.verb,\n            providerRequestOptions = _this$props.requestOptions;\n\n        _this.setState(function () {\n          return {\n            error: null,\n            loading: true\n          };\n        });\n\n        var makeRequestPath = function makeRequestPath() {\n          var url;\n\n          if (__internal_hasExplicitBase) {\n            url = verb === \"DELETE\" && typeof body === \"string\" ? composeUrl(base, \"\", composePath(path, body)) : composeUrl(base, \"\", path || \"\");\n          } else {\n            url = verb === \"DELETE\" && typeof body === \"string\" ? composeUrl(base, parentPath, composePath(path, body)) : composeUrl(base, parentPath, path);\n          } // We use ! because it's in defaultProps\n\n\n          if (Object.keys(_this.props.queryParams).length) {\n            url += \"?\" + stringify(_this.props.queryParams);\n          }\n\n          return url;\n        };\n\n        var _temp6 = typeof body === \"object\" ? JSON.stringify(body) : body;\n\n        return Promise.resolve(typeof providerRequestOptions === \"function\" ? Promise.resolve(typeof providerRequestOptions === \"function\" ? providerRequestOptions() : (providerRequestOptions || {}).headers).then(_temp5) : _temp5(typeof providerRequestOptions === \"function\" ? providerRequestOptions() : (providerRequestOptions || {}).headers));\n      } catch (e) {\n        return Promise.reject(e);\n      }\n    };\n\n    return _this;\n  }\n\n  var _proto = ContextlessMutate.prototype;\n\n  _proto.componentWillUnmount = function componentWillUnmount() {\n    this.abortController.abort();\n  };\n\n  _proto.render = function render() {\n    var _this$props2 = this.props,\n        children = _this$props2.children,\n        path = _this$props2.path,\n        base = _this$props2.base,\n        parentPath = _this$props2.parentPath;\n    var _this$state = this.state,\n        error = _this$state.error,\n        loading = _this$state.loading;\n    return children(this.mutate, {\n      loading: loading,\n      error: error\n    }, {\n      absolutePath: composeUrl(base, parentPath, path)\n    });\n  };\n\n  return ContextlessMutate;\n}(Component);\n\nContextlessMutate.defaultProps = {\n  base: \"\",\n  parentPath: \"\",\n  path: \"\",\n  queryParams: {}\n};\n/**\r\n * The <Mutate /> component _with_ context.\r\n * Context is used to compose path props,\r\n * and to maintain the base property against\r\n * which all requests will be made.\r\n *\r\n * We compose Consumers immediately with providers\r\n * in order to provide new `parentPath` props that contain\r\n * a segment of the path, creating composable URLs.\r\n */\n\nfunction Mutate(props) {\n  return createElement(RestfulReactConsumer, null, function (contextProps) {\n    return createElement(RestfulReactProvider, Object.assign({}, contextProps, {\n      parentPath: composePath(contextProps.parentPath, props.path)\n    }), createElement(ContextlessMutate, Object.assign({}, contextProps, props, {\n      queryParams: _extends({}, contextProps.queryParams, {}, props.queryParams),\n      __internal_hasExplicitBase: Boolean(props.base)\n    })));\n  });\n}\n/**\r\n * Custom version of isEqual to handle function comparison\r\n */\n\n\nvar isEqual = function isEqual(x, y) {\n  return isEqualWith(x, y, function (a, b) {\n    // Deal with the function comparison case\n    if (typeof a === \"function\" && typeof b === \"function\") {\n      return a.toString() === b.toString();\n    } // Fallback on the method\n\n\n    return undefined;\n  });\n};\n\nfunction useDeepCompareMemoize(value) {\n  var ref = useRef();\n\n  if (!isEqual(value, ref.current)) {\n    ref.current = value;\n  }\n\n  return ref.current;\n}\n/**\r\n * Accepts a function that contains imperative, possibly effectful code.\r\n *\r\n * This is the deepCompare version of the `React.useEffect` hooks (that is shallowed compare)\r\n *\r\n * @param effect Imperative function that can return a cleanup function\r\n * @param deps If present, effect will only activate if the values in the list change.\r\n *\r\n * @see https://gist.github.com/kentcdodds/fb8540a05c43faf636dd68647747b074#gistcomment-2830503\r\n */\n\n\nfunction useDeepCompareEffect(effect, deps) {\n  useEffect(effect, useDeepCompareMemoize(deps));\n}\n\nfunction createAbortController() {\n  try {\n    return new AbortController();\n  } catch (_unused) {\n    return undefined;\n  }\n}\n\nfunction useAbort() {\n  var instance = useRef(createAbortController());\n  var abort = useCallback(function () {\n    if (instance && instance.current) {\n      instance.current.abort();\n      instance.current = createAbortController();\n    }\n  }, [instance]);\n  return {\n    abort: abort,\n    getAbortSignal: function getAbortSignal() {\n      var _instance$current;\n\n      return instance === null || instance === void 0 ? void 0 : (_instance$current = instance.current) === null || _instance$current === void 0 ? void 0 : _instance$current.signal;\n    }\n  };\n}\n\nvar _fetchData = function _fetchData(props, state, setState, context, abort, getAbortSignal) {\n  try {\n    var _temp5 = function _temp5(requestOptions) {\n      function _temp3(contextRequestOptions) {\n        var signal = getAbortSignal();\n        var request = new Request(resolvePath(base, path, _extends({}, context.queryParams, {}, queryParams), props.queryParamStringifyOptions || {}), merge({}, contextRequestOptions, requestOptions, {\n          signal: signal\n        }));\n        return _catch(function () {\n          return Promise.resolve(fetch(request)).then(function (response) {\n            return Promise.resolve(processResponse(response)).then(function (_ref) {\n              var data = _ref.data,\n                  responseError = _ref.responseError;\n\n              if (signal && signal.aborted) {\n                return;\n              }\n\n              if (!response.ok || responseError) {\n                var error = {\n                  message: \"Failed to fetch: \" + response.status + \" \" + response.statusText + (responseError ? \" - \" + data : \"\"),\n                  data: data,\n                  status: response.status\n                };\n                setState(_extends({}, state, {\n                  loading: false,\n                  error: error\n                }));\n\n                if (!props.localErrorOnly && context.onError) {\n                  context.onError(error, function () {\n                    return _fetchData(props, state, setState, context, abort, getAbortSignal);\n                  }, response);\n                }\n\n                return;\n              }\n\n              setState(_extends({}, state, {\n                error: null,\n                loading: false,\n                data: resolve(data)\n              }));\n            });\n          });\n        }, function (e) {\n          // avoid state updates when component has been unmounted\n          // and when fetch/processResponse threw an error\n          if (signal && signal.aborted) {\n            return;\n          }\n\n          var error = {\n            message: \"Failed to fetch: \" + e.message,\n            data: e.message\n          };\n          setState(_extends({}, state, {\n            loading: false,\n            error: error\n          }));\n\n          if (!props.localErrorOnly && context.onError) {\n            context.onError(error, function () {\n              return _fetchData(props, state, setState, context, abort, getAbortSignal);\n            });\n          }\n        });\n      }\n\n      var _temp2 = typeof context.requestOptions === \"function\";\n\n      return _temp2 ? Promise.resolve(context.requestOptions()).then(_temp3) : _temp3(context.requestOptions);\n    };\n\n    var _props$base = props.base,\n        base = _props$base === void 0 ? context.base : _props$base,\n        path = props.path,\n        _props$resolve = props.resolve,\n        resolve = _props$resolve === void 0 ? function (d) {\n      return d;\n    } : _props$resolve,\n        _props$queryParams = props.queryParams,\n        queryParams = _props$queryParams === void 0 ? {} : _props$queryParams;\n\n    if (state.loading) {\n      // Abort previous requests\n      abort();\n    }\n\n    if (state.error || !state.loading) {\n      setState(_extends({}, state, {\n        error: null,\n        loading: true\n      }));\n    }\n\n    var _temp6 = typeof props.requestOptions === \"function\";\n\n    return Promise.resolve(_temp6 ? Promise.resolve(props.requestOptions()).then(_temp5) : _temp5(props.requestOptions));\n  } catch (e) {\n    return Promise.reject(e);\n  }\n};\n\nfunction resolvePath(base, path, queryParams, queryParamOptions) {\n  if (queryParamOptions === void 0) {\n    queryParamOptions = {};\n  }\n\n  var appendedBase = base.endsWith(\"/\") ? base : base + \"/\";\n  var trimmedPath = path.startsWith(\"/\") ? path.slice(1) : path;\n  return url.resolve(appendedBase, Object.keys(queryParams).length ? trimmedPath + \"?\" + qs__default.stringify(queryParams, queryParamOptions) : trimmedPath);\n}\n\nvar isCancellable = function isCancellable(func) {\n  return typeof func.cancel === \"function\" && typeof func.flush === \"function\";\n};\n\nfunction useGet() {\n  var props = typeof arguments[0] === \"object\" ? arguments[0] : _extends({}, arguments[1], {\n    path: arguments[0]\n  });\n  var context = useContext(Context);\n  var fetchData = useCallback(typeof props.debounce === \"object\" ? debounce(_fetchData, props.debounce.wait, props.debounce.options) : typeof props.debounce === \"number\" ? debounce(_fetchData, props.debounce) : props.debounce ? debounce(_fetchData) : _fetchData, [props.debounce]); // Cancel fetchData on unmount (if debounce)\n\n  useEffect(function () {\n    return isCancellable(fetchData) ? function () {\n      return fetchData.cancel();\n    } : undefined;\n  }, [fetchData]);\n\n  var _useState = useState({\n    data: null,\n    response: null,\n    loading: !props.lazy,\n    error: null\n  }),\n      state = _useState[0],\n      setState = _useState[1];\n\n  var _useAbort = useAbort(),\n      abort = _useAbort.abort,\n      getAbortSignal = _useAbort.getAbortSignal;\n\n  useDeepCompareEffect(function () {\n    if (!props.lazy) {\n      fetchData(props, state, setState, context, abort, getAbortSignal);\n    }\n\n    return function () {\n      abort();\n    };\n  }, [props.lazy, props.path, props.base, props.resolve, props.queryParams, props.requestOptions, abort]);\n  return _extends({}, state, {\n    absolutePath: resolvePath(props.base || context.base, props.path, _extends({}, context.queryParams, {}, props.queryParams), props.queryParamStringifyOptions),\n    cancel: function cancel() {\n      setState(_extends({}, state, {\n        loading: false\n      }));\n      abort();\n    },\n    refetch: function refetch(options) {\n      if (options === void 0) {\n        options = {};\n      }\n\n      return fetchData(_extends({}, props, {}, options), state, setState, context, abort, getAbortSignal);\n    }\n  });\n}\n\nfunction useMutate() {\n  var props = typeof arguments[0] === \"object\" ? arguments[0] : _extends({}, arguments[2], {\n    path: arguments[1],\n    verb: arguments[0]\n  });\n  var context = useContext(Context);\n  var verb = props.verb,\n      _props$base = props.base,\n      base = _props$base === void 0 ? context.base : _props$base,\n      path = props.path,\n      _props$queryParams = props.queryParams,\n      queryParams = _props$queryParams === void 0 ? {} : _props$queryParams,\n      resolve = props.resolve;\n  var isDelete = verb === \"DELETE\";\n\n  var _useState = useState({\n    error: null,\n    loading: false\n  }),\n      state = _useState[0],\n      setState = _useState[1];\n\n  var _useAbort = useAbort(),\n      abort = _useAbort.abort,\n      getAbortSignal = _useAbort.getAbortSignal; // Cancel the fetch on unmount\n\n\n  useEffect(function () {\n    return function () {\n      return abort();\n    };\n  }, [abort]);\n  var mutate = useCallback(function (body, mutateRequestOptions) {\n    try {\n      var _temp7 = function _temp7(propsRequestOptions) {\n        function _temp5(contextRequestOptions) {\n          var _exit = false;\n\n          function _temp4(_result) {\n            return _exit ? _result : Promise.resolve(processResponse(response)).then(function (_ref) {\n              var rawData = _ref.data,\n                  responseError = _ref.responseError;\n              var data; // `any` -> data in error case\n\n              try {\n                data = resolve ? resolve(rawData) : rawData;\n              } catch (e) {\n                // avoid state updates when component has been unmounted\n                // and when fetch/processResponse threw an error\n                if (signal && signal.aborted) {\n                  return;\n                }\n\n                var error = {\n                  data: e.message,\n                  message: \"Failed to resolve: \" + e.message\n                };\n                setState(function (prevState) {\n                  return _extends({}, prevState, {\n                    error: error,\n                    loading: false\n                  });\n                });\n                throw e;\n              }\n\n              if (signal && signal.aborted) {\n                return;\n              }\n\n              if (!response.ok || responseError) {\n                var _error = {\n                  data: data,\n                  message: \"Failed to fetch: \" + response.status + \" \" + response.statusText,\n                  status: response.status\n                };\n                setState(function (prevState) {\n                  return _extends({}, prevState, {\n                    error: _error,\n                    loading: false\n                  });\n                });\n\n                if (!props.localErrorOnly && context.onError) {\n                  context.onError(_error, function () {\n                    return mutate(body);\n                  }, response);\n                }\n\n                throw _error;\n              }\n\n              setState(function (prevState) {\n                return _extends({}, prevState, {\n                  loading: false\n                });\n              });\n\n              if (props.onMutate) {\n                props.onMutate(body, data);\n              }\n\n              return data;\n            });\n          }\n\n          var options = {\n            method: verb,\n            headers: {\n              \"content-type\": typeof body === \"object\" ? \"application/json\" : \"text/plain\"\n            }\n          };\n\n          if (!isDelete) {\n            options.body = typeof body === \"object\" ? JSON.stringify(body) : body;\n          }\n\n          var signal = getAbortSignal();\n          var request = new Request(resolvePath(base, isDelete ? path + \"/\" + body : path, _extends({}, context.queryParams, {}, queryParams), props.queryParamStringifyOptions), merge({}, contextRequestOptions, options, propsRequestOptions, mutateRequestOptions, {\n            signal: signal\n          }));\n          var response;\n\n          var _temp3 = _catch(function () {\n            return Promise.resolve(fetch(request)).then(function (_fetch) {\n              response = _fetch;\n            });\n          }, function (e) {\n            var error = {\n              message: \"Failed to fetch: \" + e.message,\n              data: \"\"\n            };\n            setState({\n              error: error,\n              loading: false\n            });\n\n            if (!props.localErrorOnly && context.onError) {\n              context.onError(error, function () {\n                return mutate(body, mutateRequestOptions);\n              });\n            }\n\n            throw error;\n          });\n\n          return _temp3 && _temp3.then ? _temp3.then(_temp4) : _temp4(_temp3);\n        }\n\n        var _temp2 = typeof context.requestOptions === \"function\";\n\n        return _temp2 ? Promise.resolve(context.requestOptions()).then(_temp5) : _temp5(context.requestOptions);\n      };\n\n      if (state.error || !state.loading) {\n        setState(function (prevState) {\n          return _extends({}, prevState, {\n            loading: true,\n            error: null\n          });\n        });\n      }\n\n      if (state.loading) {\n        // Abort previous requests\n        abort();\n      }\n\n      var _temp8 = typeof props.requestOptions === \"function\";\n\n      return Promise.resolve(_temp8 ? Promise.resolve(props.requestOptions()).then(_temp7) : _temp7(props.requestOptions));\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  },\n  /* eslint-disable react-hooks/exhaustive-deps */\n  [context.base, context.requestOptions, context.resolve, state.error, state.loading, path, abort, getAbortSignal]);\n  return _extends({}, state, {\n    mutate: mutate,\n    cancel: function cancel() {\n      setState(function (prevState) {\n        return _extends({}, prevState, {\n          loading: false\n        });\n      });\n      abort();\n    }\n  });\n}\n\nexport default Get;\nexport { Get, Mutate, Poll, RestfulReactProvider as RestfulProvider, useGet, useMutate };","map":{"version":3,"sources":["../node_modules/babel-plugin-transform-async-to-promises/helpers.js","../src/Context.tsx","../src/util/composeUrl.ts","../src/util/processResponse.ts","../src/util/resolveData.ts","../src/Get.tsx","../src/Poll.tsx","../src/Mutate.tsx","../src/util/useDeepCompareEffect.ts","../src/useAbort.ts","../src/useGet.tsx","../src/useMutate.tsx"],"names":["Context","React","base","parentPath","resolve","requestOptions","onError","queryParams","RestfulReactProvider","render","children","value","props","RestfulReactConsumer","composeUrl","path","composedPath","composePath","url","processResponse","response","data","responseError","e","resolveData","resolvedData","resolveError","resolvedDataOrPromise","err","message","JSON","error","ContextlessGet","debounce","loading","componentDidMount","componentDidUpdate","prevProps","isEqual","componentWillUnmount","options","extraOptions","headers","__internal_hasExplicitBase","makeRequestPath","requestPath","Object","qs","request","fetch","signal","status","resolved","wait","state","refetch","absolutePath","contextProps","Boolean","ContextlessPoll","previousData","lastResponse","polling","finished","interval","equal","lastPollIndex","Prefer","Promise","prevState","undefined","setTimeout","lazy","meta","states","actions","stop","start","contextRequestOptions","propsRequestOptions","merge","ContextlessMutate","verb","providerRequestOptions","method","body","mutateRequestOptions","isEqualWith","a","b","ref","useRef","useDeepCompareEffect","effect","deps","useEffect","useDeepCompareMemoize","useAbort","instance","createAbortController","abort","useCallback","getAbortSignal","resolvePath","queryParamOptions","appendedBase","trimmedPath","_fetchData","setState","context","isCancellable","func","useGet","arguments","useContext","fetchData","useState","cancel","useMutate","isDelete","mutate","rawData"],"mappings":"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","sourcesContent":["// A type of promise-like that resolves synchronously and supports only one observer\nexport const _Pact = /*#__PURE__*/(function() {\n\tfunction _Pact() {}\n\t_Pact.prototype.then = function(onFulfilled, onRejected) {\n\t\tconst result = new _Pact();\n\t\tconst state = this.s;\n\t\tif (state) {\n\t\t\tconst callback = state & 1 ? onFulfilled : onRejected;\n\t\t\tif (callback) {\n\t\t\t\ttry {\n\t\t\t\t\t_settle(result, 1, callback(this.v));\n\t\t\t\t} catch (e) {\n\t\t\t\t\t_settle(result, 2, e);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t} else {\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}\n\t\tthis.o = function(_this) {\n\t\t\ttry {\n\t\t\t\tconst value = _this.v;\n\t\t\t\tif (_this.s & 1) {\n\t\t\t\t\t_settle(result, 1, onFulfilled ? onFulfilled(value) : value);\n\t\t\t\t} else if (onRejected) {\n\t\t\t\t\t_settle(result, 1, onRejected(value));\n\t\t\t\t} else {\n\t\t\t\t\t_settle(result, 2, value);\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(result, 2, e);\n\t\t\t}\n\t\t};\n\t\treturn result;\n\t}\n\treturn _Pact;\n})();\n\n// Settles a pact synchronously\nexport function _settle(pact, state, value) {\n\tif (!pact.s) {\n\t\tif (value instanceof _Pact) {\n\t\t\tif (value.s) {\n\t\t\t\tif (state & 1) {\n\t\t\t\t\tstate = value.s;\n\t\t\t\t}\n\t\t\t\tvalue = value.v;\n\t\t\t} else {\n\t\t\t\tvalue.o = _settle.bind(null, pact, state);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (value && value.then) {\n\t\t\tvalue.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));\n\t\t\treturn;\n\t\t}\n\t\tpact.s = state;\n\t\tpact.v = value;\n\t\tconst observer = pact.o;\n\t\tif (observer) {\n\t\t\tobserver(pact);\n\t\t}\n\t}\n}\n\nexport function _isSettledPact(thenable) {\n\treturn thenable instanceof _Pact && thenable.s & 1;\n}\n\n// Converts argument to a function that always returns a Promise\nexport function _async(f) {\n\treturn function() {\n\t\tfor (var args = [], i = 0; i < arguments.length; i++) {\n\t\t\targs[i] = arguments[i];\n\t\t}\n\t\ttry {\n\t\t\treturn Promise.resolve(f.apply(this, args));\n\t\t} catch(e) {\n\t\t\treturn Promise.reject(e);\n\t\t}\n\t}\n}\n\n// Awaits on a value that may or may not be a Promise (equivalent to the await keyword in ES2015, with continuations passed explicitly)\nexport function _await(value, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(value) : value;\n\t}\n\tif (!value || !value.then) {\n\t\tvalue = Promise.resolve(value);\n\t}\n\treturn then ? value.then(then) : value;\n}\n\n// Awaits on a value that may or may not be a Promise, then ignores it\nexport function _awaitIgnored(value, direct) {\n\tif (!direct) {\n\t\treturn value && value.then ? value.then(_empty) : Promise.resolve();\n\t}\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continue(value, then) {\n\treturn value && value.then ? value.then(then) : then(value);\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continueIgnored(value) {\n\tif (value && value.then) {\n\t\treturn value.then(_empty);\n\t}\n}\n\n// Asynchronously iterate through an object that has a length property, passing the index as the first argument to the callback (even as the length property changes)\nexport function _forTo(array, body, check) {\n\tvar i = -1, pact, reject;\n\tfunction _cycle(result) {\n\t\ttry {\n\t\t\twhile (++i < array.length && (!check || !check())) {\n\t\t\t\tresult = body(i);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pact) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t} else {\n\t\t\t\tpact = result;\n\t\t\t}\n\t\t} catch (e) {\n\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t}\n\t}\n\t_cycle();\n\treturn pact;\n}\n\n// Asynchronously iterate through an object's properties (including properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forIn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tkeys.push(key);\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\n// Asynchronously iterate through an object's own properties (excluding properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forOwn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tif (Object.prototype.hasOwnProperty.call(target, key)) {\n\t\t\tkeys.push(key);\n\t\t}\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\nexport const _iteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.iterator || (Symbol.iterator = Symbol(\"Symbol.iterator\"))) : \"@@iterator\";\n\n// Asynchronously iterate through an object's values\n// Uses for...of if the runtime supports it, otherwise iterates until length on a copy\nexport function _forOf(target, body, check) {\n\tif (typeof target[_iteratorSymbol] === \"function\") {\n\t\tvar iterator = target[_iteratorSymbol](), step, pact, reject;\n\t\tfunction _cycle(result) {\n\t\t\ttry {\n\t\t\t\twhile (!(step = iterator.next()).done && (!check || !check())) {\n\t\t\t\t\tresult = body(step.value);\n\t\t\t\t\tif (result && result.then) {\n\t\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (pact) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t} else {\n\t\t\t\t\tpact = result;\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t\t}\n\t\t}\n\t\t_cycle();\n\t\tif (iterator.return) {\n\t\t\tvar _fixup = function(value) {\n\t\t\t\ttry {\n\t\t\t\t\tif (!step.done) {\n\t\t\t\t\t\titerator.return();\n\t\t\t\t\t}\n\t\t\t\t} catch(e) {\n\t\t\t\t}\n\t\t\t\treturn value;\n\t\t\t}\n\t\t\tif (pact && pact.then) {\n\t\t\t\treturn pact.then(_fixup, function(e) {\n\t\t\t\t\tthrow _fixup(e);\n\t\t\t\t});\n\t\t\t}\n\t\t\t_fixup();\n\t\t}\n\t\treturn pact;\n\t}\n\t// No support for Symbol.iterator\n\tif (!(\"length\" in target)) {\n\t\tthrow new TypeError(\"Object is not iterable\");\n\t}\n\t// Handle live collections properly\n\tvar values = [];\n\tfor (var i = 0; i < target.length; i++) {\n\t\tvalues.push(target[i]);\n\t}\n\treturn _forTo(values, function(i) { return body(values[i]); }, check);\n}\n\nexport const _asyncIteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol(\"Symbol.asyncIterator\"))) : \"@@asyncIterator\";\n\n// Asynchronously iterate on a value using it's async iterator if present, or its synchronous iterator if missing\nexport function _forAwaitOf(target, body, check) {\n\tif (typeof target[_asyncIteratorSymbol] === \"function\") {\n\t\tvar pact = new _Pact();\n\t\tvar iterator = target[_asyncIteratorSymbol]();\n\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\treturn pact;\n\t\tfunction _resumeAfterBody(result) {\n\t\t\tif (check && check()) {\n\t\t\t\treturn _settle(pact, 1, iterator.return ? iterator.return().then(function() { return result; }) : result);\n\t\t\t}\n\t\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\t}\n\t\tfunction _resumeAfterNext(step) {\n\t\t\tif (step.done) {\n\t\t\t\t_settle(pact, 1);\n\t\t\t} else {\n\t\t\t\tPromise.resolve(body(step.value)).then(_resumeAfterBody).then(void 0, _reject);\n\t\t\t}\n\t\t}\n\t\tfunction _reject(error) {\n\t\t\t_settle(pact, 2, iterator.return ? iterator.return().then(function() { return error; }) : error);\n\t\t}\n\t}\n\treturn Promise.resolve(_forOf(target, function(value) { return Promise.resolve(value).then(body); }, check));\n}\n\n// Asynchronously implement a generic for loop\nexport function _for(test, update, body) {\n\tvar stage;\n\tfor (;;) {\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t\tif (shouldContinue.then) {\n\t\t\tstage = 0;\n\t\t\tbreak;\n\t\t}\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.s;\n\t\t\t} else {\n\t\t\t\tstage = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (update) {\n\t\t\tvar updateValue = update();\n\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\tstage = 2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tvar pact = new _Pact();\n\tvar reject = _settle.bind(null, pact, 2);\n\t(stage === 0 ? shouldContinue.then(_resumeAfterTest) : stage === 1 ? result.then(_resumeAfterBody) : updateValue.then(_resumeAfterUpdate)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tdo {\n\t\t\tif (update) {\n\t\t\t\tupdateValue = update();\n\t\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\t\tupdateValue.then(_resumeAfterUpdate).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tshouldContinue = test();\n\t\t\tif (!shouldContinue || (_isSettledPact(shouldContinue) && !shouldContinue.v)) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t}\n\t\t} while (!result || !result.then);\n\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterBody(result);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n\tfunction _resumeAfterUpdate() {\n\t\tif (shouldContinue = test()) {\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterTest(shouldContinue);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a do ... while loop\nexport function _do(body, test) {\n\tvar awaitBody;\n\tdo {\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t} else {\n\t\t\t\tawaitBody = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t} while (!shouldContinue.then);\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : shouldContinue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tfor (;;) {\n\t\t\tshouldContinue = test();\n\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t}\n\t\t\tif (!shouldContinue) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\tresult = result.v;\n\t\t\t\t} else {\n\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tdo {\n\t\t\t\tresult = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tshouldContinue = test();\n\t\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t\t}\n\t\t\t\tif (!shouldContinue) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} while (!shouldContinue.then);\n\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a switch statement\nexport function _switch(discriminant, cases) {\n\tvar dispatchIndex = -1;\n\tvar awaitBody;\n\touter: {\n\t\tfor (var i = 0; i < cases.length; i++) {\n\t\t\tvar test = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvar testValue = test();\n\t\t\t\tif (testValue && testValue.then) {\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tif (testValue === discriminant) {\n\t\t\t\t\tdispatchIndex = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Found the default case, set it as the pending dispatch case\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tif (dispatchIndex !== -1) {\n\t\t\tdo {\n\t\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\t\twhile (!body) {\n\t\t\t\t\tdispatchIndex++;\n\t\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t\t}\n\t\t\t\tvar result = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tawaitBody = true;\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\t\tdispatchIndex++;\n\t\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t\treturn result;\n\t\t}\n\t}\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : testValue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterTest(value) {\n\t\tfor (;;) {\n\t\t\tif (value === discriminant) {\n\t\t\t\tdispatchIndex = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (++i === cases.length) {\n\t\t\t\tif (dispatchIndex !== -1) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttest = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvalue = test();\n\t\t\t\tif (value && value.then) {\n\t\t\t\t\tvalue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tdo {\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tvar result = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tdispatchIndex++;\n\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterBody(result) {\n\t\tfor (;;) {\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tif (!fallthroughCheck || fallthroughCheck()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdispatchIndex++;\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _call(body, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(body()) : body();\n\t}\n\ttry {\n\t\tvar result = Promise.resolve(body());\n\t\treturn then ? result.then(then) : result;\n\t} catch (e) {\n\t\treturn Promise.reject(e);\n\t}\n}\n\n// Asynchronously call a function and swallow the result\nexport function _callIgnored(body, direct) {\n\treturn _call(body, _empty, direct);\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _invoke(body, then) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(then);\n\t}\n\treturn then(result);\n}\n\n// Asynchronously call a function and swallow the result\nexport function _invokeIgnored(body) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(_empty);\n\t}\n}\n\n// Asynchronously call a function and send errors to recovery continuation\nexport function _catch(body, recover) {\n\ttry {\n\t\tvar result = body();\n\t} catch(e) {\n\t\treturn recover(e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(void 0, recover);\n\t}\n\treturn result;\n}\n\n// Asynchronously await a promise and pass the result to a finally continuation\nexport function _finallyRethrows(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer(true, e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer.bind(null, false), finalizer.bind(null, true));\n\t}\n\treturn finalizer(false, result);\n}\n\n// Asynchronously await a promise and invoke a finally continuation that always overrides the result\nexport function _finally(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer();\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer, finalizer);\n\t}\n\treturn finalizer();\n}\n\n// Rethrow or return a value from a finally continuation\nexport function _rethrow(thrown, value) {\n\tif (thrown)\n\t\tthrow value;\n\treturn value;\n}\n\n// Empty function to implement break and other control flow that ignores asynchronous results\nexport function _empty() {\n}\n\n// Sentinel value for early returns in generators \nexport const _earlyReturn = /*#__PURE__*/ {};\n\n// Asynchronously call a function and send errors to recovery continuation, skipping early returns\nexport function _catchInGenerator(body, recover) {\n\treturn _catch(body, function(e) {\n\t\tif (e === _earlyReturn) {\n\t\t\tthrow e;\n\t\t}\n\t\treturn recover(e);\n\t});\n}\n\n// Asynchronous generator class; accepts the entrypoint of the generator, to which it passes itself when the generator should start\nexport const _AsyncGenerator = /*#__PURE__*/(function() {\n\tfunction _AsyncGenerator(entry) {\n\t\tthis._entry = entry;\n\t\tthis._pact = null;\n\t\tthis._resolve = null;\n\t\tthis._return = null;\n\t\tthis._promise = null;\n\t}\n\n\tfunction _wrapReturnedValue(value) {\n\t\treturn { value: value, done: true };\n\t}\n\tfunction _wrapYieldedValue(value) {\n\t\treturn { value: value, done: false };\n\t}\n\n\t_AsyncGenerator.prototype._yield = function(value) {\n\t\t// Yield the value to the pending next call\n\t\tthis._resolve(value && value.then ? value.then(_wrapYieldedValue) : _wrapYieldedValue(value));\n\t\t// Return a pact for an upcoming next/return/throw call\n\t\treturn this._pact = new _Pact();\n\t};\n\t_AsyncGenerator.prototype.next = function(value) {\n\t\t// Advance the generator, starting it if it has yet to be started\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tconst _entry = _this._entry;\n\t\t\t\tif (_entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the next call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Start the generator\n\t\t\t\t_this._entry = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\tfunction returnValue(value) {\n\t\t\t\t\t_this._resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t_this._resolve = null;\n\t\t\t\t}\n\t\t\t\tvar result = _entry(_this);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tresult.then(returnValue, function(error) {\n\t\t\t\t\t\tif (error === _earlyReturn) {\n\t\t\t\t\t\t\treturnValue(_this._return);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst pact = new _Pact();\n\t\t\t\t\t\t\t_this._resolve(pact);\n\t\t\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t\t\t_this._resolve = null;\n\t\t\t\t\t\t\t_resolve(pact, 2, error);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\treturnValue(result);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Generator is started and a yield expression is pending, settle it\n\t\t\t\t_this._pact = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\t_settle(_pact, 1, value);\n\t\t\t}\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.return = function(value) {\n\t\t// Early return from the generator if started, otherwise abandons the generator\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the return call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return the specified value\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t}\n\t\t\t// Settle the yield expression with a rejected \"early return\" value\n\t\t\t_this._return = value;\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, _earlyReturn);\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.throw = function(error) {\n\t\t// Inject an exception into the pending yield expression\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve, reject) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the throw call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return a rejected Promise containing the error\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn reject(error);\n\t\t\t}\n\t\t\t// Settle the yield expression with the value as a rejection\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, error);\n\t\t});\n\t};\n\n\t_AsyncGenerator.prototype[_asyncIteratorSymbol] = function() {\n\t\treturn this;\n\t};\n\t\n\treturn _AsyncGenerator;\n})();\n","import noop from \"lodash/noop\";\nimport * as React from \"react\";\nimport { ResolveFunction } from \"./Get\";\n\nexport interface RestfulReactProviderProps<TData = any> {\n  /** The backend URL where the RESTful resources live. */\n  base: string;\n  /**\n   * The path that gets accumulated from each level of nesting\n   * taking the absolute and relative nature of each path into consideration\n   */\n  parentPath?: string;\n  /**\n   * A function to resolve data return from the backend, most typically\n   * used when the backend response needs to be adapted in some way.\n   */\n  resolve?: ResolveFunction<TData>;\n  /**\n   * Options passed to the fetch request.\n   */\n  requestOptions?: (() => Partial<RequestInit> | Promise<Partial<RequestInit>>) | Partial<RequestInit>;\n  /**\n   * Trigger on each error.\n   * For `Get` and `Mutation` calls, you can also call `retry` to retry the exact same request.\n   * Please note that it's quite hard to retrieve the response data after a retry mutation in this case.\n   * Depending of your case, it can be easier to add a `localErrorOnly` on your `Mutate` component\n   * to deal with your retry locally instead of in the provider scope.\n   */\n  onError?: (\n    err: {\n      message: string;\n      data: TData | string;\n      status?: number;\n    },\n    retry: () => Promise<TData | null>,\n    response?: Response,\n  ) => void;\n  /**\n   * Any global level query params?\n   * **Warning:** it's probably not a good idea to put API keys here. Consider headers instead.\n   */\n  queryParams?: { [key: string]: any };\n}\n\nexport const Context = React.createContext<Required<RestfulReactProviderProps>>({\n  base: \"\",\n  parentPath: \"\",\n  resolve: (data: any) => data,\n  requestOptions: {},\n  onError: noop,\n  queryParams: {},\n});\n\nexport interface InjectedProps {\n  onError: RestfulReactProviderProps[\"onError\"];\n}\n\nexport default class RestfulReactProvider<T> extends React.Component<RestfulReactProviderProps<T>> {\n  public static displayName = \"RestfulProviderContext\";\n\n  public render() {\n    const { children, ...value } = this.props;\n    return (\n      <Context.Provider\n        value={{\n          onError: noop,\n          resolve: (data: any) => data,\n          requestOptions: {},\n          parentPath: \"\",\n          queryParams: value.queryParams || {},\n          ...value,\n        }}\n      >\n        {children}\n      </Context.Provider>\n    );\n  }\n}\n\nexport const RestfulReactConsumer = Context.Consumer;\n","import url from \"url\";\n\nexport const composeUrl = (base: string = \"\", parentPath: string = \"\", path: string = \"\"): string => {\n  const composedPath = composePath(parentPath, path);\n  /* If the base is empty, preceding slash will be trimmed during composition */\n  if (base === \"\" && composedPath.startsWith(\"/\")) {\n    return composedPath;\n  }\n\n  /* If the base contains a trailing slash, it will be trimmed during composition */\n  return base!.endsWith(\"/\") ? `${base!.slice(0, -1)}${composedPath}` : `${base}${composedPath}`;\n};\n\n/**\n * If the path starts with slash, it is considered as absolute url.\n * If not, it is considered as relative url.\n * For example,\n * parentPath = \"/someBasePath\" and path = \"/absolute\" resolves to \"/absolute\"\n * whereas,\n * parentPath = \"/someBasePath\" and path = \"relative\" resolves to \"/someBasePath/relative\"\n */\nexport const composePath = (parentPath: string = \"\", path: string = \"\"): string => {\n  if (path.startsWith(\"/\") && path.length > 1) {\n    return url.resolve(parentPath, path);\n  } else if (path !== \"\" && path !== \"/\") {\n    return `${parentPath}/${path}`;\n  } else {\n    return parentPath;\n  }\n};\n","export const processResponse = async (response: Response) => {\n  if (response.status === 204) {\n    return { data: undefined, responseError: false };\n  }\n  if ((response.headers.get(\"content-type\") || \"\").includes(\"application/json\")) {\n    try {\n      return {\n        data: await response.json(),\n        responseError: false,\n      };\n    } catch (e) {\n      return {\n        data: e.message,\n        responseError: true,\n      };\n    }\n  } else {\n    return {\n      data: await response.text(),\n      responseError: false,\n    };\n  }\n};\n","import { GetDataError, ResolveFunction } from \"../types\";\n\nexport const resolveData = async <TData, TError>({\n  data,\n  resolve,\n}: {\n  data: any;\n  resolve?: ResolveFunction<TData>;\n}): Promise<{ data: TData | null; error: GetDataError<TError> | null }> => {\n  let resolvedData: TData | null = null;\n  let resolveError: GetDataError<TError> | null = null;\n  try {\n    if (resolve) {\n      const resolvedDataOrPromise: TData | Promise<TData> = resolve(data);\n      resolvedData = (resolvedDataOrPromise as { then?: any }).then\n        ? ((await resolvedDataOrPromise) as TData)\n        : (resolvedDataOrPromise as TData);\n    } else {\n      resolvedData = data;\n    }\n  } catch (err) {\n    resolvedData = null;\n    resolveError = {\n      message: \"RESOLVE_ERROR\",\n      data: JSON.stringify(err),\n    };\n  }\n  return {\n    data: resolvedData,\n    error: resolveError,\n  };\n};\n","import { DebounceSettings } from \"lodash\";\nimport debounce from \"lodash/debounce\";\nimport isEqual from \"lodash/isEqual\";\nimport * as qs from \"qs\";\nimport * as React from \"react\";\n\nimport RestfulReactProvider, { InjectedProps, RestfulReactConsumer, RestfulReactProviderProps } from \"./Context\";\nimport { composePath, composeUrl } from \"./util/composeUrl\";\nimport { processResponse } from \"./util/processResponse\";\nimport { resolveData } from \"./util/resolveData\";\n\n/**\n * A function that resolves returned data from\n * a fetch call.\n */\nexport type ResolveFunction<TData> = (data: any) => TData;\n\nexport interface GetDataError<TError> {\n  message: string;\n  data: TError | string;\n  status?: number;\n}\n\n/**\n * An enumeration of states that a fetchable\n * view could possibly have.\n */\nexport interface States<TData, TError> {\n  /** Is our view currently loading? */\n  loading: boolean;\n  /** Do we have an error in the view? */\n  error?: GetState<TData, TError>[\"error\"];\n}\n\nexport type GetMethod<TData> = () => Promise<TData | null>;\n\n/**\n * An interface of actions that can be performed\n * within Get\n */\nexport interface Actions<TData> {\n  /** Refetches the same path */\n  refetch: GetMethod<TData>;\n}\n\n/**\n * Meta information returned to the fetchable\n * view.\n */\nexport interface Meta {\n  /** The entire response object passed back from the request. */\n  response: Response | null;\n  /** The absolute path of this request. */\n  absolutePath: string;\n}\n\n/**\n * Props for the <Get /> component.\n */\nexport interface GetProps<TData, TError, TQueryParams> {\n  /**\n   * The path at which to request data,\n   * typically composed by parent Gets or the RestfulProvider.\n   */\n  path: string;\n  /**\n   * @private This is an internal implementation detail in restful-react, not meant to be used externally.\n   * This helps restful-react correctly override `path`s when a new `base` property is provided.\n   */\n  __internal_hasExplicitBase?: boolean;\n  /**\n   * A function that recieves the returned, resolved\n   * data.\n   *\n   * @param data - data returned from the request.\n   * @param actions - a key/value map of HTTP verbs, aliasing destroy to DELETE.\n   */\n  children: (data: TData | null, states: States<TData, TError>, actions: Actions<TData>, meta: Meta) => React.ReactNode;\n  /** Options passed into the fetch call. */\n  requestOptions?: RestfulReactProviderProps[\"requestOptions\"];\n  /**\n   * Query parameters\n   */\n  queryParams?: TQueryParams;\n  /**\n   * Don't send the error to the Provider\n   */\n  localErrorOnly?: boolean;\n  /**\n   * A function to resolve data return from the backend, most typically\n   * used when the backend response needs to be adapted in some way.\n   */\n  resolve?: ResolveFunction<TData>;\n  /**\n   * Should we wait until we have data before rendering?\n   * This is useful in cases where data is available too quickly\n   * to display a spinner or some type of loading state.\n   */\n  wait?: boolean;\n  /**\n   * Should we fetch data at a later stage?\n   */\n  lazy?: boolean;\n  /**\n   * An escape hatch and an alternative to `path` when you'd like\n   * to fetch from an entirely different URL.\n   *\n   */\n  base?: string;\n  /**\n   * The accumulated path from each level of parent GETs\n   *  taking the absolute and relative nature of each path into consideration\n   */\n  parentPath?: string;\n  /**\n   * How long do we wait between subsequent requests?\n   * Uses [lodash's debounce](https://lodash.com/docs/4.17.10#debounce) under the hood.\n   */\n  debounce?:\n    | {\n        wait?: number;\n        options: DebounceSettings;\n      }\n    | boolean\n    | number;\n}\n\n/**\n * State for the <Get /> component. These\n * are implementation details and should be\n * hidden from any consumers.\n */\nexport interface GetState<TData, TError> {\n  data: TData | null;\n  response: Response | null;\n  error: GetDataError<TError> | null;\n  loading: boolean;\n}\n\n/**\n * The <Get /> component without Context. This\n * is a named class because it is useful in\n * debugging.\n */\nclass ContextlessGet<TData, TError, TQueryParams> extends React.Component<\n  GetProps<TData, TError, TQueryParams> & InjectedProps,\n  Readonly<GetState<TData, TError>>\n> {\n  constructor(props: GetProps<TData, TError, TQueryParams> & InjectedProps) {\n    super(props);\n\n    if (typeof props.debounce === \"object\") {\n      this.fetch = debounce(this.fetch, props.debounce.wait, props.debounce.options);\n    } else if (typeof props.debounce === \"number\") {\n      this.fetch = debounce(this.fetch, props.debounce);\n    } else if (props.debounce) {\n      this.fetch = debounce(this.fetch);\n    }\n  }\n\n  /**\n   * Abort controller to cancel the current fetch query\n   */\n  private abortController = new AbortController();\n  private signal = this.abortController.signal;\n\n  public readonly state: Readonly<GetState<TData, TError>> = {\n    data: null, // Means we don't _yet_ have data.\n    response: null,\n    loading: !this.props.lazy,\n    error: null,\n  };\n\n  public static defaultProps = {\n    base: \"\",\n    parentPath: \"\",\n    resolve: (unresolvedData: any) => unresolvedData,\n    queryParams: {},\n  };\n\n  public componentDidMount() {\n    if (!this.props.lazy) {\n      this.fetch();\n    }\n  }\n\n  public componentDidUpdate(prevProps: GetProps<TData, TError, TQueryParams>) {\n    const { base, parentPath, path, resolve, queryParams } = prevProps;\n    if (\n      base !== this.props.base ||\n      parentPath !== this.props.parentPath ||\n      path !== this.props.path ||\n      !isEqual(queryParams, this.props.queryParams) ||\n      // both `resolve` props need to _exist_ first, and then be equivalent.\n      (resolve && this.props.resolve && resolve.toString() !== this.props.resolve.toString())\n    ) {\n      if (!this.props.lazy) {\n        this.fetch();\n      }\n    }\n  }\n\n  public componentWillUnmount() {\n    this.abortController.abort();\n  }\n\n  public getRequestOptions = async (\n    extraOptions?: Partial<RequestInit>,\n    extraHeaders?: boolean | { [key: string]: string },\n  ) => {\n    const { requestOptions } = this.props;\n\n    if (typeof requestOptions === \"function\") {\n      const options = (await requestOptions()) || {};\n      return {\n        ...extraOptions,\n        ...options,\n        headers: new Headers({\n          ...(typeof extraHeaders !== \"boolean\" ? extraHeaders : {}),\n          ...(extraOptions || {}).headers,\n          ...options.headers,\n        }),\n      };\n    }\n\n    return {\n      ...extraOptions,\n      ...requestOptions,\n      headers: new Headers({\n        ...(typeof extraHeaders !== \"boolean\" ? extraHeaders : {}),\n        ...(extraOptions || {}).headers,\n        ...(requestOptions || {}).headers,\n      }),\n    };\n  };\n\n  public fetch = async (requestPath?: string, thisRequestOptions?: RequestInit) => {\n    const { base, __internal_hasExplicitBase, parentPath, path, resolve } = this.props;\n    if (this.state.error || !this.state.loading) {\n      this.setState(() => ({ error: null, loading: true }));\n    }\n\n    const makeRequestPath = () => {\n      let url: string;\n      if (__internal_hasExplicitBase) {\n        url = composeUrl(base!, \"\", path || \"\");\n      } else {\n        url = composeUrl(base!, parentPath!, requestPath || path || \"\");\n      }\n\n      // We use ! because it's in defaultProps\n      if (Object.keys(this.props.queryParams!).length) {\n        url += `?${qs.stringify(this.props.queryParams)}`;\n      }\n      return url;\n    };\n\n    const request = new Request(makeRequestPath(), await this.getRequestOptions(thisRequestOptions));\n    try {\n      const response = await fetch(request, { signal: this.signal });\n      const { data, responseError } = await processResponse(response);\n\n      // avoid state updates when component has been unmounted\n      if (this.signal.aborted) {\n        return;\n      }\n\n      if (!response.ok || responseError) {\n        const error = {\n          message: `Failed to fetch: ${response.status} ${response.statusText}${responseError ? \" - \" + data : \"\"}`,\n          data,\n          status: response.status,\n        };\n\n        this.setState({\n          loading: false,\n          error,\n        });\n\n        if (!this.props.localErrorOnly && this.props.onError) {\n          this.props.onError(error, () => this.fetch(requestPath, thisRequestOptions), response);\n        }\n\n        return null;\n      }\n\n      const resolved = await resolveData<TData, TError>({ data, resolve });\n\n      this.setState({ loading: false, data: resolved.data, error: resolved.error });\n      return data;\n    } catch (e) {\n      // avoid state updates when component has been unmounted\n      // and when fetch/processResponse threw an error\n      if (this.signal.aborted) {\n        return;\n      }\n\n      this.setState({\n        loading: false,\n        error: {\n          message: `Failed to fetch: ${e.message}`,\n          data: e,\n        },\n      });\n    }\n  };\n\n  public render() {\n    const { children, wait, path, base, parentPath } = this.props;\n    const { data, error, loading, response } = this.state;\n\n    if (wait && data === null && !error) {\n      return <></>; // Show nothing until we have data.\n    }\n\n    return children(\n      data,\n      { loading, error },\n      { refetch: this.fetch },\n      { response, absolutePath: composeUrl(base!, parentPath!, path) },\n    );\n  }\n}\n\n/**\n * The <Get /> component _with_ context.\n * Context is used to compose path props,\n * and to maintain the base property against\n * which all requests will be made.\n *\n * We compose Consumers immediately with providers\n * in order to provide new `parentPath` props that contain\n * a segment of the path, creating composable URLs.\n */\nfunction Get<TData = any, TError = any, TQueryParams = { [key: string]: any }>(\n  props: GetProps<TData, TError, TQueryParams>,\n) {\n  return (\n    <RestfulReactConsumer>\n      {contextProps => (\n        <RestfulReactProvider {...contextProps} parentPath={composePath(contextProps.parentPath, props.path)}>\n          <ContextlessGet\n            {...contextProps}\n            {...props}\n            queryParams={{ ...contextProps.queryParams, ...props.queryParams }}\n            __internal_hasExplicitBase={Boolean(props.base)}\n          />\n        </RestfulReactProvider>\n      )}\n    </RestfulReactConsumer>\n  );\n}\n\nexport default Get;\n","import merge from \"lodash/merge\";\nimport * as qs from \"qs\";\nimport * as React from \"react\";\nimport equal from \"react-fast-compare\";\n\nimport { InjectedProps, RestfulReactConsumer } from \"./Context\";\nimport { GetProps, GetState, Meta as GetComponentMeta } from \"./Get\";\nimport { composeUrl } from \"./util/composeUrl\";\nimport { processResponse } from \"./util/processResponse\";\n\n/**\n * Meta information returned from the poll.\n */\ninterface Meta extends GetComponentMeta {\n  /**\n   * The entire response object.\n   */\n  response: Response | null;\n}\n\n/**\n * States of the current poll\n */\ninterface States<TData, TError> {\n  /**\n   * Is the component currently polling?\n   */\n  polling: PollState<TData, TError>[\"polling\"];\n  /**\n   * Is the initial request loading?\n   */\n  loading: PollState<TData, TError>[\"loading\"];\n  /**\n   * Has the poll concluded?\n   */\n  finished: PollState<TData, TError>[\"finished\"];\n  /**\n   * Is there an error? What is it?\n   */\n  error: PollState<TData, TError>[\"error\"];\n}\n\n/**\n * Actions that can be executed within the\n * component.\n */\ninterface Actions {\n  start: () => void;\n  stop: () => void;\n}\n\n/**\n * Props that can control the Poll component.\n */\nexport interface PollProps<TData, TError, TQueryParams> {\n  /**\n   * What path are we polling on?\n   */\n  path: GetProps<TData, TError, TQueryParams>[\"path\"];\n  /**\n   * A function that gets polled data, the current\n   * states, meta information, and various actions\n   * that can be executed at the poll-level.\n   */\n  children: (data: TData | null, states: States<TData, TError>, actions: Actions, meta: Meta) => React.ReactNode;\n  /**\n   * How long do we wait between repeating a request?\n   * Value in milliseconds.\n   *\n   * Defaults to 1000.\n   */\n  interval?: number;\n  /**\n   * How long should a request stay open?\n   * Value in seconds.\n   *\n   * Defaults to 60.\n   */\n  wait?: number;\n  /**\n   * A stop condition for the poll that expects\n   * a boolean.\n   *\n   * @param data - The data returned from the poll.\n   * @param response - The full response object. This could be useful in order to stop polling when !response.ok, for example.\n   */\n  until?: (data: TData | null, response: Response | null) => boolean;\n  /**\n   * Are we going to wait to start the poll?\n   * Use this with { start, stop } actions.\n   */\n  lazy?: GetProps<TData, TError, TQueryParams>[\"lazy\"];\n  /**\n   * Should the data be transformed in any way?\n   */\n  resolve?: (data: any, prevData: TData | null) => TData;\n  /**\n   * We can request foreign URLs with this prop.\n   */\n  base?: GetProps<TData, TError, TQueryParams>[\"base\"];\n  /**\n   * Any options to be passed to this request.\n   */\n  requestOptions?: GetProps<TData, TError, TQueryParams>[\"requestOptions\"];\n  /**\n   * Query parameters\n   */\n  queryParams?: TQueryParams;\n  /**\n   * Don't send the error to the Provider\n   */\n  localErrorOnly?: boolean;\n}\n\n/**\n * The state of the Poll component. This should contain\n * implementation details not necessarily exposed to\n * consumers.\n */\nexport interface PollState<TData, TError> {\n  /**\n   * Are we currently polling?\n   */\n  polling: boolean;\n  /**\n   * Have we finished polling?\n   */\n  finished: boolean;\n  /**\n   * What was the last response?\n   */\n  lastResponse: Response | null;\n  /**\n   * What data are we holding in here?\n   */\n  data: GetState<TData, TError>[\"data\"];\n  /**\n   * What data did we had before?\n   */\n  previousData: GetState<TData, TError>[\"data\"];\n  /**\n   * Are we loading?\n   */\n  loading: GetState<TData, TError>[\"loading\"];\n  /**\n   * Do we currently have an error?\n   */\n  error: GetState<TData, TError>[\"error\"];\n  /**\n   * Index of the last polled response.\n   */\n  lastPollIndex?: string;\n}\n\n/**\n * The <Poll /> component without context.\n */\nclass ContextlessPoll<TData, TError, TQueryParams> extends React.Component<\n  PollProps<TData, TError, TQueryParams> & InjectedProps,\n  Readonly<PollState<TData, TError>>\n> {\n  public readonly state: Readonly<PollState<TData, TError>> = {\n    data: null,\n    previousData: null,\n    loading: !this.props.lazy,\n    lastResponse: null,\n    polling: !this.props.lazy,\n    finished: false,\n    error: null,\n  };\n\n  public static defaultProps = {\n    interval: 1000,\n    wait: 60,\n    base: \"\",\n    resolve: (data: any) => data,\n    queryParams: {},\n  };\n\n  private keepPolling = !this.props.lazy;\n\n  /**\n   * Abort controller to cancel the current fetch query\n   */\n  private abortController = new AbortController();\n  private signal = this.abortController.signal;\n\n  private isModified = (response: Response, nextData: TData) => {\n    if (response.status === 304) {\n      return false;\n    }\n    if (equal(this.state.data, nextData)) {\n      return false;\n    }\n    return true;\n  };\n\n  private getRequestOptions = () =>\n    typeof this.props.requestOptions === \"function\" ? this.props.requestOptions() : this.props.requestOptions || {};\n\n  // 304 is not a OK status code but is green in Chrome 🤦🏾‍♂️\n  private isResponseOk = (response: Response) => response.ok || response.status === 304;\n\n  /**\n   * This thing does the actual poll.\n   */\n  public cycle = async () => {\n    // Have we stopped?\n    if (!this.keepPolling) {\n      return; // stop.\n    }\n\n    // Should we stop?\n    if (this.props.until && this.props.until(this.state.data, this.state.lastResponse)) {\n      await this.stop(); // stop.\n      return;\n    }\n\n    // If we should keep going,\n    const { base, path, interval, wait } = this.props;\n    const { lastPollIndex } = this.state;\n    const requestOptions = await this.getRequestOptions();\n\n    let url = composeUrl(base!, \"\", path);\n\n    // We use a ! because it's in defaultProps\n    if (Object.keys(this.props.queryParams!).length) {\n      url += `?${qs.stringify(this.props.queryParams)}`;\n    }\n\n    const request = new Request(url, {\n      ...requestOptions,\n      headers: {\n        Prefer: `wait=${wait}s;${lastPollIndex ? `index=${lastPollIndex}` : \"\"}`,\n        ...requestOptions.headers,\n      },\n    });\n\n    try {\n      const response = await fetch(request, { signal: this.signal });\n      const { data, responseError } = await processResponse(response);\n\n      if (!this.keepPolling || this.signal.aborted) {\n        // Early return if we have stopped polling or component was unmounted\n        // to avoid memory leaks\n        return;\n      }\n\n      if (!this.isResponseOk(response) || responseError) {\n        const error = {\n          message: `Failed to poll: ${response.status} ${response.statusText}${responseError ? \" - \" + data : \"\"}`,\n          data,\n          status: response.status,\n        };\n        this.setState({ loading: false, lastResponse: response, error });\n\n        if (!this.props.localErrorOnly && this.props.onError) {\n          this.props.onError(error, () => Promise.resolve(), response);\n        }\n      } else if (this.isModified(response, data)) {\n        this.setState(prevState => ({\n          loading: false,\n          lastResponse: response,\n          previousData: prevState.data,\n          data,\n          error: null,\n          lastPollIndex: response.headers.get(\"x-polling-index\") || undefined,\n        }));\n      }\n\n      // Wait for interval to pass.\n      await new Promise(resolvePromise => setTimeout(resolvePromise, interval));\n      this.cycle(); // Do it all again!\n    } catch (e) {\n      // the only error not catched is the `fetch`, this means that we have cancelled the fetch\n    }\n  };\n\n  public start = () => {\n    this.keepPolling = true;\n    if (!this.state.polling) {\n      this.setState(() => ({ polling: true })); // let everyone know we're done here.\n    }\n    this.cycle();\n  };\n\n  public stop = () => {\n    this.keepPolling = false;\n    this.setState(() => ({ polling: false, finished: true })); // let everyone know we're done here.\n  };\n\n  public componentDidMount() {\n    const { path, lazy } = this.props;\n\n    if (path === undefined) {\n      throw new Error(\n        `[restful-react]: You're trying to poll something without a path. Please specify a \"path\" prop on your Poll component.`,\n      );\n    }\n\n    if (!lazy) {\n      this.start();\n    }\n  }\n\n  public componentWillUnmount() {\n    // Cancel the current query\n    this.abortController.abort();\n\n    // Stop the polling cycle\n    this.stop();\n  }\n\n  public render() {\n    const { lastResponse: response, previousData, data, polling, loading, error, finished } = this.state;\n    const { children, base, path, resolve } = this.props;\n\n    const meta: Meta = {\n      response,\n      absolutePath: composeUrl(base!, \"\", path),\n    };\n\n    const states: States<TData, TError> = {\n      polling,\n      loading,\n      error,\n      finished,\n    };\n\n    const actions: Actions = {\n      stop: this.stop,\n      start: this.start,\n    };\n    // data is parsed only when poll has already resolved so response is defined\n    const resolvedData = response && resolve ? resolve(data, previousData) : data;\n    return children(resolvedData, states, actions, meta);\n  }\n}\n\nfunction Poll<TData = any, TError = any, TQueryParams = { [key: string]: any }>(\n  props: PollProps<TData, TError, TQueryParams>,\n) {\n  // Compose Contexts to allow for URL nesting\n  return (\n    <RestfulReactConsumer>\n      {contextProps => {\n        const contextRequestOptions =\n          typeof contextProps.requestOptions === \"function\"\n            ? contextProps.requestOptions()\n            : contextProps.requestOptions || {};\n        const propsRequestOptions =\n          typeof props.requestOptions === \"function\" ? props.requestOptions() : props.requestOptions || {};\n\n        return (\n          <ContextlessPoll\n            {...contextProps}\n            {...props}\n            queryParams={{ ...contextProps.queryParams, ...props.queryParams }}\n            requestOptions={async () => merge(await contextRequestOptions, await propsRequestOptions)}\n          />\n        );\n      }}\n    </RestfulReactConsumer>\n  );\n}\n\nexport default Poll;\n","import * as qs from \"qs\";\nimport * as React from \"react\";\nimport RestfulReactProvider, { InjectedProps, RestfulReactConsumer, RestfulReactProviderProps } from \"./Context\";\nimport { GetState } from \"./Get\";\nimport { composePath, composeUrl } from \"./util/composeUrl\";\nimport { processResponse } from \"./util/processResponse\";\n\n/**\n * An enumeration of states that a fetchable\n * view could possibly have.\n */\nexport interface States<TData, TError> {\n  /** Is our view currently loading? */\n  loading: boolean;\n  /** Do we have an error in the view? */\n  error?: GetState<TData, TError>[\"error\"];\n}\n\nexport type MutateMethod<TData, TRequestBody> = (\n  data: TRequestBody,\n  mutateRequestOptions?: RequestInit,\n) => Promise<TData>;\n\n/**\n * Meta information returned to the fetchable\n * view.\n */\nexport interface Meta {\n  /** The absolute path of this request. */\n  absolutePath: string;\n}\n\n/**\n * Props for the <Mutate /> component.\n */\nexport interface MutateProps<TData, TError, TQueryParams, TRequestBody> {\n  /**\n   * The path at which to request data,\n   * typically composed by parents or the RestfulProvider.\n   */\n  path?: string;\n  /**\n   * @private This is an internal implementation detail in restful-react, not meant to be used externally.\n   * This helps restful-react correctly override `path`s when a new `base` property is provided.\n   */\n  __internal_hasExplicitBase?: boolean;\n  /**\n   * What HTTP verb are we using?\n   */\n  verb: \"POST\" | \"PUT\" | \"PATCH\" | \"DELETE\";\n  /**\n   * Query parameters\n   */\n  queryParams?: TQueryParams;\n  /**\n   * An escape hatch and an alternative to `path` when you'd like\n   * to fetch from an entirely different URL.\n   *\n   */\n  base?: string;\n  /**\n   * The accumulated path from each level of parent GETs\n   *  taking the absolute and relative nature of each path into consideration\n   */\n  parentPath?: string;\n  /** Options passed into the fetch call. */\n  requestOptions?: RestfulReactProviderProps[\"requestOptions\"];\n  /**\n   * Don't send the error to the Provider\n   */\n  localErrorOnly?: boolean;\n  /**\n   * A function that recieves a mutation function, along with\n   * some metadata.\n   *\n   * @param actions - a key/value map of HTTP verbs, aliasing destroy to DELETE.\n   */\n  children: (mutate: MutateMethod<TData, TRequestBody>, states: States<TData, TError>, meta: Meta) => React.ReactNode;\n  /**\n   * Callback called after the mutation is done.\n   *\n   * @param body - Body given to mutate\n   * @param data - Response data\n   */\n  onMutate?: (body: TRequestBody, data: TData) => void;\n}\n\n/**\n * State for the <Mutate /> component. These\n * are implementation details and should be\n * hidden from any consumers.\n */\nexport interface MutateState<TData, TError> {\n  error: GetState<TData, TError>[\"error\"];\n  loading: boolean;\n}\n\n/**\n * The <Mutate /> component without Context. This\n * is a named class because it is useful in\n * debugging.\n */\nclass ContextlessMutate<TData, TError, TQueryParams, TRequestBody> extends React.Component<\n  MutateProps<TData, TError, TQueryParams, TRequestBody> & InjectedProps,\n  MutateState<TData, TError>\n> {\n  public readonly state: Readonly<MutateState<TData, TError>> = {\n    loading: false,\n    error: null,\n  };\n\n  public static defaultProps = {\n    base: \"\",\n    parentPath: \"\",\n    path: \"\",\n    queryParams: {},\n  };\n\n  /**\n   * Abort controller to cancel the current fetch query\n   */\n  private abortController = new AbortController();\n  private signal = this.abortController.signal;\n\n  public componentWillUnmount() {\n    this.abortController.abort();\n  }\n\n  public mutate = async (body: TRequestBody, mutateRequestOptions?: RequestInit) => {\n    const {\n      __internal_hasExplicitBase,\n      base,\n      parentPath,\n      path,\n      verb,\n      requestOptions: providerRequestOptions,\n    } = this.props;\n    this.setState(() => ({ error: null, loading: true }));\n\n    const makeRequestPath = () => {\n      let url: string;\n      if (__internal_hasExplicitBase) {\n        url =\n          verb === \"DELETE\" && typeof body === \"string\"\n            ? composeUrl(base!, \"\", composePath(path!, body))\n            : composeUrl(base!, \"\", path || \"\");\n      } else {\n        url =\n          verb === \"DELETE\" && typeof body === \"string\"\n            ? composeUrl(base!, parentPath!, composePath(path!, body))\n            : composeUrl(base!, parentPath!, path!);\n      }\n\n      // We use ! because it's in defaultProps\n      if (Object.keys(this.props.queryParams!).length) {\n        url += `?${qs.stringify(this.props.queryParams)}`;\n      }\n      return url;\n    };\n\n    const request = new Request(makeRequestPath(), {\n      method: verb,\n      body: typeof body === \"object\" ? JSON.stringify(body) : body,\n      ...(typeof providerRequestOptions === \"function\" ? providerRequestOptions() : providerRequestOptions),\n      ...mutateRequestOptions,\n      headers: {\n        \"content-type\": typeof body === \"object\" ? \"application/json\" : \"text/plain\",\n        ...(typeof providerRequestOptions === \"function\"\n          ? (await providerRequestOptions()).headers\n          : (providerRequestOptions || {}).headers),\n        ...(mutateRequestOptions ? mutateRequestOptions.headers : {}),\n      },\n    } as RequestInit); // Type assertion for version of TypeScript that can't yet discriminate.\n\n    let response: Response;\n    try {\n      response = await fetch(request, { signal: this.signal });\n    } catch (e) {\n      const error = {\n        message: `Failed to fetch: ${e.message}`,\n        data: \"\",\n      };\n\n      this.setState({\n        error,\n        loading: false,\n      });\n\n      if (!this.props.localErrorOnly && this.props.onError) {\n        this.props.onError(error, () => this.mutate(body, mutateRequestOptions));\n      }\n\n      throw error;\n    }\n\n    const { data, responseError } = await processResponse(response);\n\n    // avoid state updates when component has been unmounted\n    if (this.signal.aborted) {\n      return;\n    }\n    if (!response.ok || responseError) {\n      const error = {\n        data,\n        message: `Failed to fetch: ${response.status} ${response.statusText}`,\n        status: response.status,\n      };\n\n      this.setState({\n        error,\n        loading: false,\n      });\n\n      if (!this.props.localErrorOnly && this.props.onError) {\n        this.props.onError(error, () => this.mutate(body, mutateRequestOptions), response);\n      }\n\n      throw error;\n    }\n\n    this.setState({ loading: false });\n\n    if (this.props.onMutate) {\n      this.props.onMutate(body, data);\n    }\n\n    return data;\n  };\n\n  public render() {\n    const { children, path, base, parentPath } = this.props;\n    const { error, loading } = this.state;\n\n    return children(this.mutate, { loading, error }, { absolutePath: composeUrl(base!, parentPath!, path!) });\n  }\n}\n\n/**\n * The <Mutate /> component _with_ context.\n * Context is used to compose path props,\n * and to maintain the base property against\n * which all requests will be made.\n *\n * We compose Consumers immediately with providers\n * in order to provide new `parentPath` props that contain\n * a segment of the path, creating composable URLs.\n */\nfunction Mutate<TData = any, TError = any, TQueryParams = { [key: string]: any }, TRequestBody = any>(\n  props: MutateProps<TData, TError, TQueryParams, TRequestBody>,\n) {\n  return (\n    <RestfulReactConsumer>\n      {contextProps => (\n        <RestfulReactProvider {...contextProps} parentPath={composePath(contextProps.parentPath, props.path!)}>\n          <ContextlessMutate<TData, TError, TQueryParams, TRequestBody>\n            {...contextProps}\n            {...props}\n            queryParams={{ ...contextProps.queryParams, ...props.queryParams } as TQueryParams}\n            __internal_hasExplicitBase={Boolean(props.base)}\n          />\n        </RestfulReactProvider>\n      )}\n    </RestfulReactConsumer>\n  );\n}\n\nexport default Mutate;\n","import isEqualWith from \"lodash/isEqualWith\";\nimport React, { useEffect, useRef } from \"react\";\n\n/**\n * Custom version of isEqual to handle function comparison\n */\nconst isEqual = (x: any, y: any) =>\n  isEqualWith(x, y, (a, b) => {\n    // Deal with the function comparison case\n    if (typeof a === \"function\" && typeof b === \"function\") {\n      return a.toString() === b.toString();\n    }\n    // Fallback on the method\n    return undefined;\n  });\n\nfunction useDeepCompareMemoize(value: Readonly<any>) {\n  const ref = useRef<any>();\n\n  if (!isEqual(value, ref.current)) {\n    ref.current = value;\n  }\n\n  return ref.current;\n}\n\n/**\n * Accepts a function that contains imperative, possibly effectful code.\n *\n * This is the deepCompare version of the `React.useEffect` hooks (that is shallowed compare)\n *\n * @param effect Imperative function that can return a cleanup function\n * @param deps If present, effect will only activate if the values in the list change.\n *\n * @see https://gist.github.com/kentcdodds/fb8540a05c43faf636dd68647747b074#gistcomment-2830503\n */\nexport function useDeepCompareEffect<T>(effect: React.EffectCallback, deps: T) {\n  useEffect(effect, useDeepCompareMemoize(deps));\n}\n","import { useCallback, useRef } from \"react\";\n\nfunction createAbortController() {\n  try {\n    return new AbortController();\n  } catch {\n    return undefined;\n  }\n}\n\nexport function useAbort() {\n  const instance = useRef(createAbortController());\n\n  const abort = useCallback(() => {\n    if (instance && instance.current) {\n      instance.current.abort();\n      instance.current = createAbortController();\n    }\n  }, [instance]);\n\n  return {\n    abort,\n    getAbortSignal() {\n      return instance?.current?.signal;\n    },\n  };\n}\n","import { useCallback, useContext, useEffect, useState } from \"react\";\nimport { Cancelable, DebounceSettings } from \"lodash\";\nimport debounce from \"lodash/debounce\";\nimport merge from \"lodash/merge\";\nimport qs, { IStringifyOptions } from \"qs\";\nimport url from \"url\";\n\nimport { Context, RestfulReactProviderProps } from \"./Context\";\nimport { GetState } from \"./Get\";\nimport { processResponse } from \"./util/processResponse\";\nimport { useDeepCompareEffect } from \"./util/useDeepCompareEffect\";\nimport { useAbort } from \"./useAbort\";\n\nexport type Omit<T, K extends keyof T> = Pick<T, Exclude<keyof T, K>>;\n\nexport interface UseGetProps<TData, TQueryParams> {\n  /**\n   * The path at which to request data,\n   * typically composed by parent Gets or the RestfulProvider.\n   */\n  path: string;\n  /** Options passed into the fetch call. */\n  requestOptions?: RestfulReactProviderProps[\"requestOptions\"];\n  /**\n   * Query parameters\n   */\n  queryParams?: TQueryParams;\n  /**\n   * Query parameter stringify options\n   */\n  queryParamStringifyOptions?: IStringifyOptions;\n  /**\n   * Don't send the error to the Provider\n   */\n  localErrorOnly?: boolean;\n  /**\n   * A function to resolve data return from the backend, most typically\n   * used when the backend response needs to be adapted in some way.\n   */\n  resolve?: (data: any) => TData;\n  /**\n   * Should we fetch data at a later stage?\n   */\n  lazy?: boolean;\n  /**\n   * An escape hatch and an alternative to `path` when you'd like\n   * to fetch from an entirely different URL.\n   *\n   */\n  base?: string;\n  /**\n   * How long do we wait between subsequent requests?\n   * Uses [lodash's debounce](https://lodash.com/docs/4.17.10#debounce) under the hood.\n   */\n  debounce?:\n    | {\n        wait?: number;\n        options: DebounceSettings;\n      }\n    | boolean\n    | number;\n}\n\nexport function resolvePath<TQueryParams>(\n  base: string,\n  path: string,\n  queryParams: TQueryParams,\n  queryParamOptions: IStringifyOptions = {},\n) {\n  const appendedBase = base.endsWith(\"/\") ? base : `${base}/`;\n  const trimmedPath = path.startsWith(\"/\") ? path.slice(1) : path;\n\n  return url.resolve(\n    appendedBase,\n    Object.keys(queryParams).length ? `${trimmedPath}?${qs.stringify(queryParams, queryParamOptions)}` : trimmedPath,\n  );\n}\n\nasync function _fetchData<TData, TError, TQueryParams>(\n  props: UseGetProps<TData, TQueryParams>,\n  state: GetState<TData, TError>,\n  setState: (newState: GetState<TData, TError>) => void,\n  context: RestfulReactProviderProps,\n  abort: () => void,\n  getAbortSignal: () => AbortSignal | undefined,\n) {\n  const { base = context.base, path, resolve = (d: any) => d as TData, queryParams = {} } = props;\n\n  if (state.loading) {\n    // Abort previous requests\n    abort();\n  }\n\n  if (state.error || !state.loading) {\n    setState({ ...state, error: null, loading: true });\n  }\n\n  const requestOptions =\n    (typeof props.requestOptions === \"function\" ? await props.requestOptions() : props.requestOptions) || {};\n\n  const contextRequestOptions =\n    (typeof context.requestOptions === \"function\" ? await context.requestOptions() : context.requestOptions) || {};\n\n  const signal = getAbortSignal();\n\n  const request = new Request(\n    resolvePath(base, path, { ...context.queryParams, ...queryParams }, props.queryParamStringifyOptions || {}),\n    merge({}, contextRequestOptions, requestOptions, { signal }),\n  );\n\n  try {\n    const response = await fetch(request);\n    const { data, responseError } = await processResponse(response);\n\n    if (signal && signal.aborted) {\n      return;\n    }\n\n    if (!response.ok || responseError) {\n      const error = {\n        message: `Failed to fetch: ${response.status} ${response.statusText}${responseError ? \" - \" + data : \"\"}`,\n        data,\n        status: response.status,\n      };\n\n      setState({ ...state, loading: false, error });\n\n      if (!props.localErrorOnly && context.onError) {\n        context.onError(error, () => _fetchData(props, state, setState, context, abort, getAbortSignal), response);\n      }\n      return;\n    }\n\n    setState({ ...state, error: null, loading: false, data: resolve(data) });\n  } catch (e) {\n    // avoid state updates when component has been unmounted\n    // and when fetch/processResponse threw an error\n    if (signal && signal.aborted) {\n      return;\n    }\n\n    const error = {\n      message: `Failed to fetch: ${e.message}`,\n      data: e.message,\n    };\n\n    setState({\n      ...state,\n      loading: false,\n      error,\n    });\n\n    if (!props.localErrorOnly && context.onError) {\n      context.onError(error, () => _fetchData(props, state, setState, context, abort, getAbortSignal));\n    }\n  }\n}\n\ntype FetchData = typeof _fetchData;\ntype CancellableFetchData = FetchData | (FetchData & Cancelable);\ntype RefetchOptions<TData, TQueryParams> = Partial<Omit<UseGetProps<TData, TQueryParams>, \"lazy\">>;\n\nconst isCancellable = <T extends (...args: any[]) => any>(func: T): func is T & Cancelable => {\n  return typeof (func as any).cancel === \"function\" && typeof (func as any).flush === \"function\";\n};\n\nexport interface UseGetReturn<TData, TError, TQueryParams = {}> extends GetState<TData, TError> {\n  /**\n   * Absolute path resolved from `base` and `path` (context & local)\n   */\n  absolutePath: string;\n  /**\n   * Cancel the current fetch\n   */\n  cancel: () => void;\n  /**\n   * Refetch\n   */\n  refetch: (options?: RefetchOptions<TData, TQueryParams>) => Promise<void>;\n}\n\nexport function useGet<TData = any, TError = any, TQueryParams = { [key: string]: any }>(\n  path: string,\n  props?: Omit<UseGetProps<TData, TQueryParams>, \"path\">,\n): UseGetReturn<TData, TError, TQueryParams>;\n\nexport function useGet<TData = any, TError = any, TQueryParams = { [key: string]: any }>(\n  props: UseGetProps<TData, TQueryParams>,\n): UseGetReturn<TData, TError, TQueryParams>;\n\nexport function useGet<TData = any, TError = any, TQueryParams = { [key: string]: any }>() {\n  const props: UseGetProps<TData, TError> =\n    typeof arguments[0] === \"object\" ? arguments[0] : { ...arguments[1], path: arguments[0] };\n\n  const context = useContext(Context);\n\n  const fetchData = useCallback<CancellableFetchData>(\n    typeof props.debounce === \"object\"\n      ? debounce<FetchData>(_fetchData, props.debounce.wait, props.debounce.options)\n      : typeof props.debounce === \"number\"\n      ? debounce<FetchData>(_fetchData, props.debounce)\n      : props.debounce\n      ? debounce<FetchData>(_fetchData)\n      : _fetchData,\n    [props.debounce],\n  );\n\n  // Cancel fetchData on unmount (if debounce)\n  useEffect(() => (isCancellable(fetchData) ? () => fetchData.cancel() : undefined), [fetchData]);\n\n  const [state, setState] = useState<GetState<TData, TError>>({\n    data: null,\n    response: null,\n    loading: !props.lazy,\n    error: null,\n  });\n\n  const { abort, getAbortSignal } = useAbort();\n\n  useDeepCompareEffect(() => {\n    if (!props.lazy) {\n      fetchData(props, state, setState, context, abort, getAbortSignal);\n    }\n\n    return () => {\n      abort();\n    };\n  }, [props.lazy, props.path, props.base, props.resolve, props.queryParams, props.requestOptions, abort]);\n\n  return {\n    ...state,\n    absolutePath: resolvePath(\n      props.base || context.base,\n      props.path,\n      {\n        ...context.queryParams,\n        ...props.queryParams,\n      },\n      props.queryParamStringifyOptions,\n    ),\n    cancel: () => {\n      setState({\n        ...state,\n        loading: false,\n      });\n      abort();\n    },\n    refetch: (options: RefetchOptions<TData, TQueryParams> = {}) =>\n      fetchData({ ...props, ...options }, state, setState, context, abort, getAbortSignal),\n  };\n}\n","import merge from \"lodash/merge\";\nimport { useCallback, useContext, useEffect, useState } from \"react\";\nimport { Context } from \"./Context\";\nimport { MutateMethod, MutateState } from \"./Mutate\";\nimport { Omit, resolvePath, UseGetProps } from \"./useGet\";\nimport { processResponse } from \"./util/processResponse\";\nimport { useAbort } from \"./useAbort\";\n\nexport interface UseMutateProps<TData, TQueryParams, TRequestBody>\n  extends Omit<UseGetProps<TData, TQueryParams>, \"lazy\" | \"debounce\"> {\n  /**\n   * What HTTP verb are we using?\n   */\n  verb: \"POST\" | \"PUT\" | \"PATCH\" | \"DELETE\";\n  /**\n   * Callback called after the mutation is done.\n   *\n   * @param body - Body given to mutate\n   * @param data - Response data\n   */\n  onMutate?: (body: TRequestBody, data: TData) => void;\n}\n\nexport interface UseMutateReturn<TData, TError, TRequestBody> extends MutateState<TData, TError> {\n  /**\n   * Cancel the current fetch\n   */\n  cancel: () => void;\n  /**\n   * Call the mutate endpoint\n   */\n  mutate: MutateMethod<TData, TRequestBody>;\n}\n\nexport function useMutate<TData = any, TError = any, TQueryParams = { [key: string]: any }, TRequestBody = any>(\n  props: UseMutateProps<TData, TQueryParams, TRequestBody>,\n): UseMutateReturn<TData, TError, TRequestBody>;\n\nexport function useMutate<TData = any, TError = any, TQueryParams = { [key: string]: any }, TRequestBody = any>(\n  verb: UseMutateProps<TData, TQueryParams, TRequestBody>[\"verb\"],\n  path: string,\n  props?: Omit<UseMutateProps<TData, TQueryParams, TRequestBody>, \"path\" | \"verb\">,\n): UseMutateReturn<TData, TError, TRequestBody>;\n\nexport function useMutate<\n  TData = any,\n  TError = any,\n  TQueryParams = { [key: string]: any },\n  TRequestBody = any\n>(): UseMutateReturn<TData, TError, TRequestBody> {\n  const props: UseMutateProps<TData, TQueryParams, TRequestBody> =\n    typeof arguments[0] === \"object\" ? arguments[0] : { ...arguments[2], path: arguments[1], verb: arguments[0] };\n\n  const context = useContext(Context);\n  const { verb, base = context.base, path, queryParams = {}, resolve } = props;\n  const isDelete = verb === \"DELETE\";\n\n  const [state, setState] = useState<MutateState<TData, TError>>({\n    error: null,\n    loading: false,\n  });\n\n  const { abort, getAbortSignal } = useAbort();\n\n  // Cancel the fetch on unmount\n  useEffect(() => () => abort(), [abort]);\n\n  const mutate = useCallback<MutateMethod<TData, TRequestBody>>(\n    async (body: TRequestBody, mutateRequestOptions?: RequestInit) => {\n      if (state.error || !state.loading) {\n        setState(prevState => ({ ...prevState, loading: true, error: null }));\n      }\n\n      if (state.loading) {\n        // Abort previous requests\n        abort();\n      }\n\n      const propsRequestOptions =\n        (typeof props.requestOptions === \"function\" ? await props.requestOptions() : props.requestOptions) || {};\n\n      const contextRequestOptions =\n        (typeof context.requestOptions === \"function\" ? await context.requestOptions() : context.requestOptions) || {};\n\n      const options: RequestInit = {\n        method: verb,\n        headers: {\n          \"content-type\": typeof body === \"object\" ? \"application/json\" : \"text/plain\",\n        },\n      };\n\n      if (!isDelete) {\n        options.body = typeof body === \"object\" ? JSON.stringify(body) : ((body as unknown) as string);\n      }\n\n      const signal = getAbortSignal();\n\n      const request = new Request(\n        resolvePath(\n          base,\n          isDelete ? `${path}/${body}` : path,\n          { ...context.queryParams, ...queryParams },\n          props.queryParamStringifyOptions,\n        ),\n        merge({}, contextRequestOptions, options, propsRequestOptions, mutateRequestOptions, { signal }),\n      );\n\n      let response: Response;\n      try {\n        response = await fetch(request);\n      } catch (e) {\n        const error = {\n          message: `Failed to fetch: ${e.message}`,\n          data: \"\",\n        };\n\n        setState({\n          error,\n          loading: false,\n        });\n\n        if (!props.localErrorOnly && context.onError) {\n          context.onError(error, () => mutate(body, mutateRequestOptions));\n        }\n\n        throw error;\n      }\n\n      const { data: rawData, responseError } = await processResponse(response);\n\n      let data: TData | any; // `any` -> data in error case\n      try {\n        data = resolve ? resolve(rawData) : rawData;\n      } catch (e) {\n        // avoid state updates when component has been unmounted\n        // and when fetch/processResponse threw an error\n        if (signal && signal.aborted) {\n          return;\n        }\n\n        const error = {\n          data: e.message,\n          message: `Failed to resolve: ${e.message}`,\n        };\n\n        setState(prevState => ({\n          ...prevState,\n          error,\n          loading: false,\n        }));\n        throw e;\n      }\n\n      if (signal && signal.aborted) {\n        return;\n      }\n\n      if (!response.ok || responseError) {\n        const error = {\n          data,\n          message: `Failed to fetch: ${response.status} ${response.statusText}`,\n          status: response.status,\n        };\n\n        setState(prevState => ({\n          ...prevState,\n          error,\n          loading: false,\n        }));\n\n        if (!props.localErrorOnly && context.onError) {\n          context.onError(error, () => mutate(body), response);\n        }\n\n        throw error;\n      }\n\n      setState(prevState => ({ ...prevState, loading: false }));\n\n      if (props.onMutate) {\n        props.onMutate(body, data);\n      }\n\n      return data;\n    },\n    /* eslint-disable react-hooks/exhaustive-deps */\n    [context.base, context.requestOptions, context.resolve, state.error, state.loading, path, abort, getAbortSignal],\n  );\n\n  return {\n    ...state,\n    mutate,\n    cancel: () => {\n      setState(prevState => ({\n        ...prevState,\n        loading: false,\n      }));\n      abort();\n    },\n  };\n}\n"]},"metadata":{},"sourceType":"module"}